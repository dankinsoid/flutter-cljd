(ns flutter-cljd.types
  (:require
   ["package:flutter/foundation.dart" :as fd]
   ["package:flutter/material.dart" :as m]
   ["package:flutter/services.dart" :as s]
   ["package:flutter/widgets.dart" :as w]
   ["package:flutter/animation.dart" :as a]
   ["package:flutter/rendering.dart" :as r]
   ["dart:core" :as dc]
   ["dart:ui" :as ui]
   ["dart:math" :as math]
   ["package:vector_math/vector_math_64.dart" :as vec-math]
   [cljd.string :as str]
   [cljd.flutter :as f]
   [cljd.core :as c]
   [flutter-cljd.keyboard-keys :as keys]
   [flutter-cljd.color-filters :as clr-f]
   [flutter-cljd.types :as t]
   [flutter-cljd.utils :as ut]
   [flutter-cljd.shader :as shader]))

(deftype ^:private AnyActionDispatcher [invoke]
  :extends w/ActionDispatcher
  (invokeAction [action intent context]
    (let [result (invoke action intent context)]
      (.invokeAction ^super action intent context)
      result))
  (invokeActionIfEnabled [action intent context]
    (let [result (invoke action intent context)
          enabled (.-$1 (.invokeActionIfEnabled ^super action intent context))]
      (list enabled result)))) ;; TODO create a tuple

(defn ^w/ActionDispatcher action-dispatcher
  "An interface for dispatching actions to a `FocusNode`.
   
   This is used with `FocusNode.onKey` to allow the `FocusNode` to handle key events.
   
   [Flutter docs](https://api.flutter.dev/flutter/services/ActionDispatcher-class.html)"
  [dispatcher]
  (cond
    (instance? w/ActionDispatcher dispatcher) dispatcher
    ;; TODO (fn? dispatcher) (AnyActionDispatcher dispatcher)
    :else (throw (Exception. (str "Invalid dispatcher: " dispatcher ", `ActionDispatcher` was expected.")))))

(defn ^m/Axis axis
  "Returns the `Axis` enum value for the specified axis.
   
   The two cardinal directions in two dimensions.

   The axis is always relative to the current coordinate space.
   This means, for example, that a horizontal axis might actually be diagonally from top right to bottom left, due to some local Transform applied to the scene.

   Possible values:
   - instance of Axis
   - `:horizontal` or `:h`
   - `:vertical` or `:v`
   
   [Flutter docs](https://api.flutter.dev/flutter/painting/Axis.html)"
  [axis]
  (if (instance? m/Axis axis)
    axis
    (case axis
      (:horizontal :h) m/Axis.horizontal
      (:vertical :v) m/Axis.vertical
      (throw (Exception. (str "Invalid axis: " axis))))))

(defn ^m/AxisDirection axis-direction
  "Returns the `AxisDirection` enum value for the specified axis direction.
   
  A direction along either the horizontal or vertical axis in which the origin, or zero position, is determined.

   This value relates to the direction in which the scroll offset increases from the origin.
   This value does not represent the direction of user input that may be modifying the scroll offset, such as from a drag.
   For the active scrolling direction, see scroll-direction.

   Possible values:
   - instance of `AxisDirection`
   - `:up` or `:u`
   - `:down` or `:d`
   - `:left` or `:l`
   - `:right` or `:r`
   
   [Flutter docs](https://api.flutter.dev/flutter/painting/AxisDirection.html)"
  [direction]
  (if (instance? m/AxisDirection direction)
    direction
    (case direction
      (:up :u) m/AxisDirection.up
      (:down :d) m/AxisDirection.down
      (:left :l) m/AxisDirection.left
      (:right :r) m/AxisDirection.right
      (throw (Exception. (str "Invalid axis-direction: " direction))))))

(defn ^m/BlendMode blend-mode
  "Returns the `BlendMode` enum value for the specified blend mode.
   
   Algorithms to use when painting on the canvas.

   When drawing a shape or image onto a canvas, different algorithms can be used to blend the pixels.
   The different values of `BlendMode` specify different such algorithms.
   
   [Flutter docs](https://api.flutter.dev/flutter/dart-ui/BlendMode.html)"
  [mode]
  (if (instance? m/BlendMode mode)
    mode
    (case mode
      :clear m/BlendMode.clear
      :src m/BlendMode.src
      :dst m/BlendMode.dst
      :src-over m/BlendMode.srcOver
      :dst-over m/BlendMode.dstOver
      :src-in m/BlendMode.srcIn
      :dst-in m/BlendMode.dstIn
      :src-out m/BlendMode.srcOut
      :dst-out m/BlendMode.dstOut
      :src-atop m/BlendMode.srcATop
      :dst-atop m/BlendMode.dstATop
      :xor m/BlendMode.xor
      :plus m/BlendMode.plus
      :modulate m/BlendMode.modulate
      :screen m/BlendMode.screen
      :overlay m/BlendMode.overlay
      :darken m/BlendMode.darken
      :lighten m/BlendMode.lighten
      :color-dodge m/BlendMode.colorDodge
      :color-burn m/BlendMode.colorBurn
      :hard-light m/BlendMode.hardLight
      :soft-light m/BlendMode.softLight
      :difference m/BlendMode.difference
      :exclusion m/BlendMode.exclusion
      :multiply m/BlendMode.multiply
      :hue m/BlendMode.hue
      :saturation m/BlendMode.saturation
      :color m/BlendMode.color
      :luminosity m/BlendMode.luminosity
      (throw (Exception. (str "Invalid blend-mode: " mode))))))

(defn ^m/BlurStyle blur-style
  "Styles to use for blurs in MaskFilter objects.
   
   Possible values:
    - instance of `BlurStyle`
    - `:normal` Fuzzy inside and outside. This is useful for painting shadows that are offset from the shape that ostensibly is casting the shadow.
    - `:solid` Solid inside, fuzzy outside. This corresponds to drawing the shape, and additionally drawing the blur. This can make objects appear brighter, maybe even as if they were fluorescent.
    - `:outer` Nothing inside, fuzzy outside. This is useful for painting shadows for partially transparent shapes, when they are painted separately but without an offset, so that the shadow doesn't paint below the shape.
    - `:inner` Fuzzy inside, nothing outside. This can make shapes appear to be lit from within. 

   [Flutter docs](https://api.flutter.dev/flutter/dart-ui/BlurStyle-class.html)"
  [style]
  (if (instance? m/BlurStyle style)
    style
    (case style
      :normal m/BlurStyle.normal
      :solid m/BlurStyle.solid
      :outer m/BlurStyle.outer
      :inner m/BlurStyle.inner
      (throw (Exception. (str "Invalid blur-style: " style))))))

(defn ^m/CrossAxisAlignment cross-axis-alignment [alignment]
  (if (instance? m/CrossAxisAlignment alignment)
    alignment
    (case alignment
      :center m/CrossAxisAlignment.center
      :start m/CrossAxisAlignment.start
      :end m/CrossAxisAlignment.end
      :stretch m/CrossAxisAlignment.stretch
      :baseline m/CrossAxisAlignment.baseline
      (throw (Exception. (str "Invalid cross-axis-alignment: " alignment))))))

(defn ^m/MainAxisAlignment main-axis-alignment [alignment]
  (if (instance? m/MainAxisAlignment alignment)
    alignment
    (case alignment
      :center m/MainAxisAlignment.center
      :start m/MainAxisAlignment.start
      :end m/MainAxisAlignment.end
      :space-between m/MainAxisAlignment.spaceBetween
      :space-around m/MainAxisAlignment.spaceAround
      :space-evenly m/MainAxisAlignment.spaceEvenly
      (throw (Exception. (str "Invalid main-axis-alignment: " alignment))))))

(defn ^m/MainAxisSize main-axis-size [size]
  (if (instance? m/MainAxisSize size)
    size
    (case size
      :max m/MainAxisSize.max
      :min m/MainAxisSize.min
      (throw (Exception. (str "Invalid main-axis-size: " size))))))

(defn ^m/VerticalDirection vertical-direction [direction]
  (if (instance? m/VerticalDirection direction)
    direction
    (case direction
      :up m/VerticalDirection.up
      :down m/VerticalDirection.down
      (throw (Exception. (str "Invalid vertical-direction: " direction))))))

(defn ^m/TextDirection text-direction [direction]
  (if (instance? m/TextDirection direction)
    direction
    (case direction
      :ltr m/TextDirection.ltr
      :rtl m/TextDirection.rtl
      (throw (Exception. (str "Invalid text-direction: " direction))))))

(defn ^m/TextBaseline text-baseline [baseline]
  (if (instance? m/TextBaseline baseline)
    baseline
    (case baseline
      :alphabetic m/TextBaseline.alphabetic
      :ideographic m/TextBaseline.ideographic
      (throw (Exception. (str "Invalid text-baseline: " baseline))))))

(defn ^m/AutofillContextAction autofill-context-action
  "Predefined autofill context clean up actions.
   
   Can be `:commit`, `:cancel` or an `AutofillContextAction`.
   
   Returns an `AutofillContextAction`"
  [action]
  (cond
    (instance? m/AutofillContextAction action) action
    (= action :commit) m/AutofillContextAction.commit
    (= action :cancel) m/AutofillContextAction.cancel
    :else (throw (Exception. (str "Invalid autofill-context-action: " action)))))

(defn ^m/BannerLocation banner-location
  [location]
  (if (instance? m/BannerLocation location)
    location
    (case location
      :top-start m/BannerLocation.topStart
      :start-top m/BannerLocation.topStart
      :top-end m/BannerLocation.topEnd
      :end-top m/BannerLocation.topEnd
      :bottom-start m/BannerLocation.bottomStart
      :start-bottom m/BannerLocation.bottomStart
      :bottom-end m/BannerLocation.bottomEnd
      :end-bottom m/BannerLocation.bottomEnd
      (throw (Exception. (str "Invalid banner-location: " location))))))

(defn ^w/KeyEventResult key-event-result [result]
  (if
   (instance? w/KeyEventResult result)
    result
    (case result
      :handled w/KeyEventResult.handled
      :ignored w/KeyEventResult.ignored
      :skip-remaining-handlers w/KeyEventResult.skipRemainingHandlers
      w/KeyEventResult.handled)))

(defn ^w/LockState lock-state
  "Determines how the state of a lock key is used to accept a shortcut.
   
   Possible values:
    - instance of `LockState`
    - `:locked` The lock key must be locked to trigger the shortcut.
    - `:unlocked` The lock key must be unlocked to trigger the shortcut.
    - `:ignored` The lock key state is not used to determine SingleActivator.accepts result.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/LockState.html)"
  [state]
  (if (instance? w/LockState state)
    state
    (case state
      :locked w/LockState.locked
      :unlocked w/LockState.unlocked
      :ignored w/LockState.ignored
      (throw (Exception. (str "Invalid lock-state: " state))))))

(defn ^m/Clip clip
  "Determines how to clip a widget's content.
   
   Possible values:
    - instance of `Clip`
    - `:none` No clip.
    - `:hard-edge` Clip with a hard edge.
    - `:anti-alias` Clip with anti-aliasing.
    - `:anti-alias-with-save-layer` Clip with anti-aliasing and saveLayer.
   
   [Flutter docs](https://api.flutter.dev/flutter/dart-ui/Clip.html)"
  [clip]
  (if (instance? m/Clip clip)
    clip
    (case clip
      :none m/Clip.none
      :hard-edge m/Clip.hardEdge
      :anti-alias m/Clip.antiAlias
      :anti-alias-with-save-layer m/Clip.antiAliasWithSaveLayer
      (throw (Exception. (str "Invalid clip: " clip))))))

(defn ^m/DecorationPosition decoration-position [position]
  (if (instance? m/DecorationPosition position)
    position
    (case position
      :background m/DecorationPosition.background
      :foreground m/DecorationPosition.foreground
      (throw (Exception. (str "Invalid decoration-position: " position " (expected :background or :foreground)"))))))

;; ;; -------------------------
;; ;; MARK: Classes
;; ;; -------------------------

(defn ^m/Alignment alignment [alignment]
  (cond
    (instance? m/Alignment alignment) alignment

    (vector? alignment)
    (m/Alignment (get alignment 0) (get alignment 1 (get alignment 0)))

    (number? alignment)
    (m/Alignment alignment alignment)

    (keyword? alignment)
    (case alignment
      ;; Top alignments 
      (:top :top-center :center-top) m/Alignment.topCenter
      (:top-left :left-top) m/Alignment.topLeft
      (:top-right :right-top) m/Alignment.topRight

      ;; Left alignments
      (:left :left-center :center-left) m/Alignment.centerLeft

      ;; Bottom alignments
      (:bottom :bottom-center :center-bottom) m/Alignment.bottomCenter
      (:bottom-left :left-bottom) m/Alignment.bottomLeft
      (:bottom-right :right-bottom) m/Alignment.bottomRight

      ;; Right alignments
      (:right :right-center :center-right) m/Alignment.centerRight

      ;; Center alignment
      :center m/Alignment.center

      (throw (Exception. (str "Invalid alignment: " alignment))))

    :else (throw (Exception. (str "Invalid alignment: " alignment)))))

(defn ^m/AlignmentGeometry alignment-geometry [alignment]
  (cond
    (instance? m/AlignmentGeometry alignment) alignment

    (vector? alignment)
    (m/AlignmentDirectional (get alignment 0) (get alignment 1 (get alignment 0)))

    (number? alignment)
    (m/AlignmentDirectional alignment alignment)

    (keyword? alignment)
    (case alignment
      ;; Top alignments 
      (:top :top-center :center-top) m/Alignment.topCenter
      (:top-left :left-top) m/Alignment.topLeft
      (:top-start :start-top) m/AlignmentDirectional.topStart
      (:top-right :right-top) m/Alignment.topRight
      (:top-end :end-top) m/AlignmentDirectional.topEnd

      ;; Left alignments
      (:left :left-center :center-left) m/Alignment.centerLeft
      (:start :start-center :center-start) m/AlignmentDirectional.centerStart

      ;; Bottom alignments
      (:bottom :bottom-center :center-bottom) m/Alignment.bottomCenter
      (:bottom-left :left-bottom) m/Alignment.bottomLeft
      (:bottom-start :start-bottom) m/AlignmentDirectional.bottomStart
      (:bottom-right :right-bottom) m/Alignment.bottomRight
      (:bottom-end :end-bottom) m/AlignmentDirectional.bottomEnd

      ;; Right alignments
      (:right :right-center :center-right) m/Alignment.centerRight
      (:end :end-center :center-end) m/AlignmentDirectional.centerEnd

      ;; Center alignment
      :center m/Alignment.center

      (throw (Exception. (str "Invalid alignment: " alignment))))

    :else (throw (Exception. (str "Invalid alignment: " alignment)))))

(defn ^m/PlaceholderAlignment placeholder-alignment [alignment]
  (if (instance? m/PlaceholderAlignment alignment)
    alignment
    (case alignment
      :baseline m/PlaceholderAlignment.baseline
      :above-baseline m/PlaceholderAlignment.aboveBaseline
      :below-baseline m/PlaceholderAlignment.belowBaseline
      :top m/PlaceholderAlignment.top
      :bottom m/PlaceholderAlignment.bottom
      :middle m/PlaceholderAlignment.middle
      (throw (Exception. (str "Invalid placeholder-alignment: " alignment))))))

(defn ^m/StackFit stack-fit [fit]
  (if (instance? m/StackFit fit)
    fit
    (case fit
      :loose m/StackFit.loose
      :expand m/StackFit.expand
      :passthrough m/StackFit.passthrough
      (throw (Exception. (str "Invalid stackFit: " fit))))))

(defn ^m/EdgeInsetsGeometry insets
  "Creates an EdgeInsetsGeometry object from the specified insets.
   Insets can be specified as a number or a map or key-value pairs of edge names to numbers or a STEB sequence.
   Examples:
   ```clojure
    (insets 4) ;; EdgeInsetsDirectional.all(4)
    (insets {:top 4}) ;; EdgeInsetsDirectional.only(top: 4)
    (insets {:horizontal 4 :top 8}) ;; EdgeInsetsDirectional.only(start: 4, top: 8, end: 4)
    (insets {:left 4}) ;; EdgeInsets.only(left: 4)
    (insets {:end 4}) ;; EdgeInsetsDirectional.only(end: 4)
    (insets :top 1 :all 4) ;; EdgeInsetsDirectional.only(start: 4, top: 1, end: 4, bottom: 4)
    (insets 4 8 4 8) ;; EdgeInsetsDirectional.fromSTEB(4, 8, 4, 8)
    (insets {:t 4 :b 2 :h 8}) ;; EdgeInsetsDirectional.only(start: 8, top: 4, end: 8, bottom: 2)
   ```
   By default `EdgeInsetsDirectional` class is used, but `EdgeInsets` class is used if the insets contains a key `:left` or `:right`.

   If the insets contains a key :all, the value is used for all not explicitly specified edges.

   If the insets argument is an EdgeInsetsGeometry object, it is returned as is."
  ([] (insets {}))
  ([& values]
   (cond
     (and (= (count values) 4) (every? number? values))
     (let [[s t e b] values]
       (m/EdgeInsetsDirectional.fromSTEB s t e b))

     (= (count values) 1)
     (let [value (last values)]
       (cond
         (instance? m/EdgeInsetsGeometry value) value

         (number? value) (m/EdgeInsetsDirectional.all value)

         (map? value)
         (if (> (some value [:left :l :right :r]) 0)
           (m/EdgeInsets.fromLTRB
            (or (some value [:left :l :horizontal :h :all]) 0)
            (or (some value [:top :t :vertical :v :all]) 0)
            (or (some value [:right :r :horizontal :h :all]) 0)
            (or (some value [:bottom :b :vertical :v :all]) 0))
           (m/EdgeInsetsDirectional.fromSTEB
            (or (some value [:start :s :horizontal :h :all]) 0)
            (or (some value [:top :t :vertical :v :all]) 0)
            (or (some value [:end :e :horizontal :h :all]) 0)
            (or (some value [:bottom :b :vertical :v :all]) 0)))

         (and (= (count value) 4) (every? number? value))
         (m/EdgeInsetsDirectional.fromSTEB (get value 0 0) (get value 1 0) (get value 2 0) (get value 3 0))

         :else (throw (Exception. (str "Invalid edgeInsets: " value)))))

     :else
     (insets (apply hash-map values)))))

(defn ^m/EdgeInsetsGeometry merge-insets
  "Merges the specified insets with the default insets.
   The insets can be specified as a number or a map of edge names to numbers or a STEB sequence."
  [& value]
  (reduce #(.add %1 %2) (m/EdgeInsets.zero) (map insets value)))

(defn ^m/TextAlign text-align [align]
  (if (instance? m/TextAlign align)
    align
    (case align
      :left m/TextAlign.left
      :right m/TextAlign.right
      :center m/TextAlign.center
      :justify m/TextAlign.justify
      :start m/TextAlign.start
      :end m/TextAlign.end
      (throw (Exception. (str "Invalid text-align: " align))))))

(defn ^m/FontWeight font-weight [weight]
  (cond
    (instance? m/FontWeight weight) weight

    (number? weight)
    (let [weight (min 100 (max 900 weight))]
      (or
       (m/FontWeight.lerp
        m/FontWeight.w100
        m/FontWeight.w900
        (/ (- weight 100) 800.0))
       m/FontWeight.normal))

    (keyword? weight)
    (case weight
      :w100 m/FontWeight.w100
      :w200 m/FontWeight.w200
      :w300 m/FontWeight.w300
      :w400 m/FontWeight.w400
      :w500 m/FontWeight.w500
      :w600 m/FontWeight.w600
      :w700 m/FontWeight.w700
      :w800 m/FontWeight.w800
      :w900 m/FontWeight.w900
      :normal m/FontWeight.normal
      :bold m/FontWeight.bold
      :light m/FontWeight.w300
      :medium m/FontWeight.w500
      :semi-bold m/FontWeight.w600
      :extra-bold m/FontWeight.w800
      :extra-light m/FontWeight.w200
      :thin m/FontWeight.w100
      :black m/FontWeight.w900)

    :else
    (throw (Exception. (str "Invalid font-weight: " weight)))))

(defn ^m/FontStyle font-style [style]
  (if (instance? m/FontStyle style)
    style
    (case style
      :italic m/FontStyle.italic
      m/FontStyle.normal)))

(defn ^m/TextLeadingDistribution text-leading-distribution [distribution]
  (if (instance? m/TextLeadingDistribution distribution)
    distribution
    (case distribution
      :proportional m/TextLeadingDistribution.proportional
      :even m/TextLeadingDistribution.even
      m/TextLeadingDistribution.proportional)))

(defn locale [locale]
  (if (instance? m/Locale locale)
    locale
    (m/Locale locale)))

(defn ^m/Color color
  "Returns a `Color` object for the specified color.

   Possible values:
    - instance of `Color`
    - a vector of length 3 or 4: [r g b] or [r g b o]
    - a number: 0xRRGGBB or 0xAARRGGBB
    - a hex string: \"#RRGGBB\" or \"#AARRGGBB\". Prefer using the number format for better performance.
    - a keyword: :blue, :red, :green, :yellow, :orange, :purple, :pink, :cyan, :teal, :amber, :lime, :light-blue, :light-green, :deep-orange, :deep-purple, :indigo, :blue-grey, :grey, :black, :white, :transparent

   [Flutter docs](https://api.flutter.dev/flutter/dart-ui/Color-class.html)"
  ([r g b] (m/Color.fromRGBO r g b 1.0))
  ([r g b o] (m/Color.fromRGBO r g b o))
  ([value]
   (cond
     (instance? m/Color value) value
     (number? value) (m/Color value)
     (string? value) (let [hex (-> value str/lower-case)]
                       (if (re-matches #"^#([0-9a-f]{6}|[0-9a-f]{8})$" hex)
                         (m/Color (if (= (count hex) 7)
                                    (dc/int.parse (str "0xff" (subs hex 1)))
                                    (dc/int.parse (str "0x" (subs hex 1)))))
                         (throw (Exception. (str "Invalid color hex: " value)))))

     (keyword? value) (case value
                        :blue m/Colors.blue
                        :red m/Colors.red
                        :green m/Colors.green
                        :yellow m/Colors.yellow
                        :orange m/Colors.orange
                        :purple m/Colors.purple
                        :pink m/Colors.pink
                        :cyan m/Colors.cyan
                        :teal m/Colors.teal
                        :amber m/Colors.amber
                        :lime m/Colors.lime
                        :light-blue m/Colors.lightBlue
                        :light-green m/Colors.lightGreen
                        :deep-orange m/Colors.deepOrange
                        :deep-purple m/Colors.deepPurple
                        :indigo m/Colors.indigo
                        :blue-grey m/Colors.blueGrey
                        :grey m/Colors.grey
                        :gray m/Colors.grey
                        :black m/Colors.black
                        :white m/Colors.white
                        :transparent m/Colors.transparent
                        (throw (Exception. (str "Unknown color keyword: " value))))
     :else (m/Color value))))

(defn ^m/ColorFilter color-filter
  "A description of a color filter to apply when drawing a shape or compositing a layer with a particular Paint.
   A color filter is a function that takes two colors, and outputs one color.
   When applied during compositing, it is independently applied to each pixel of the layer being drawn before the entire layer is merged with the destination.

   Instances of this class are used with Paint.colorFilter on Paint objects.

   Possible values:
    - instance of `ColorFilter`
    - `:linear-to-srgb-gamma` Linear to sRGB gamma.
    - `:srgb-to-linear-gamma` sRGB to linear gamma.
    - `:identity` Identity color filter.
    - `:invert` Invert color filter.
    - `:sepia` Sepia color filter.
    - `:greyscale` Greyscale color filter.
    - a vector of length 2: [color blend-mode]
    - a 4x5 row-major matrix as a vector of numbers or a vector of vectors of numbers where first 4 rows represent red, green, blue and alpha channels respectively.
   4th row can be omitted, in which case it is assumed to be [0, 0, 0, 1, 0].

   ```clojure
    (color-filter :invert)

    (color-filter [:red :multiply])

    (color-filter [0.393 0.769 0.189 0 0
                   0.349 0.686 0.168 0 0
                   0.272 0.534 0.131 0 0])
   ```
   [Flutter docs](https://api.flutter.dev/flutter/dart-ui/ColorFilter-class.html)"
  [filter]
  (cond
    (instance? m/ColorFilter filter) filter

    (keyword? filter)
    (case filter
      :linear-to-srgb-gamma (m/ColorFilter.linearToSrgbGamma)
      :srgb-to-linear-gamma (m/ColorFilter.srgbToLinearGamma)
      :identity clr-f/identity
      :invert clr-f/invert
      :sepia clr-f/sepia
      :greyscale clr-f/greyscale
      (throw (Exception. (str "Invalid color-filter keyword: " filter ", use :linear-to-srgb-gamma, :srgb-to-linear-gamma, :identity, :invert, :sepia, :greyscale"))))

    (vector? filter)
    (case (count filter)
      2 (m/ColorFilter.mode (color (get filter 0)) (blend-mode (get filter 1)))
      (let [dim 5
            size 20
            values (->> filter flatten (take size) vec)]
        (m/ColorFilter.matrix (#/(dc/List.from dc/double)
                               (map-indexed
                                (fn [idx _]
                                  (cond
                                    (< idx (count values)) (double (nth values idx))
                                    (= (mod idx dim) (quot idx dim)) 1.0
                                    :else 0.0))
                                (range 0 size))))))

    :else (throw (Exception. (str "Invalid color-filter: " filter)))))

(defn ^m/TextStyle text-style
  "An immutable style describing how to format and paint text.

   Args:
    - `:inherit` (boolean, default: true): Whether the style is inherited from the parent. 
    - `:color` (Color, default: nil): The color of the text.
    - `:background-color` (Color, default: nil): The background color of the text.
    - `:size` or `:font-size` (number, default: nil): The size of the font.
    - `:weight` or `:font-weight` (number or FontWeight, default: nil): The weight of the font.
    - `:font-style` (keyword or FontStyle, default: nil): The style of the font.
    - `:letter-spacing` (number, default: nil): The spacing between letters.
    - `:word-spacing` (number, default: nil): The spacing between words.
    - `:text-baseline` (keyword or TextBaseline, default: nil): The baseline alignment for the text.
    - `:height` or `:h` (number, default: nil): The height of the text.
    - `:leading-distribution` (keyword or TextLeadingDistribution, default: nil): The leading distribution of the text.
    - `:locale` (Locale, default: nil): The locale to use for the text.
    - `:foreground` (Paint, default: nil): The foreground paint of the text.
    - `:background` (Paint, default: nil): The background paint of the text.
    - `:shadows` (list of Shadow, default: nil): The shadows of the text.
    - `:font-features` (list of FontFeature, default: nil): The font features of the text.
    - `:font-variations` (list of FontVariation, default: nil): The font variations of the text.
    - `:decoration` (TextDecoration, default: nil): The decoration of the text.
    - `:decoration-color` (Color, default: nil): The color of the decoration.
    - `:decoration-style` (TextDecorationStyle, default: nil): The style of the decoration.
    - `:decoration-thickness` (number, default: nil): The thickness of the decoration.
    - `:debug-label` (string, default: nil): The debug label of the text.
    - `:family` or `:font-family` (string, default: nil): The font family of the text.
    - `:font-family-fallback` (list of string, default: nil): The font family fallback of the text.
    - `:package` (string, default: nil): The package of the font family.
    - `:overflow` (TextOverflow, default: nil): How the text should behave when it overflows."
  [arg0 & args]
  (let [args (if (empty? args) arg0 (apply hash-map (cons arg0 args)))]
    (cond
      (instance? m/TextStyle args)
      args

      (map? args)
      (m/TextStyle
       .inherit (:inherit args true)
       .color (some-> (args :color) color)
       .backgroundColor (some-> (args :background-color) color)
       .fontSize (:size args (:font-size args))
       .fontWeight (some-> (:weight args (:font-weight args)) font-weight)
       .fontStyle (some-> (args :font-style) font-style)
       .letterSpacing (args :letter-spacing)
       .wordSpacing (args :word-spacing)
       .textBaseline (some-> (args :text-baseline) text-baseline)
       .height (get args :height (args :h))
       .leadingDistribution (some-> (args :leading-distribution) text-leading-distribution)
       .locale (some-> (args :locale) locale)
       .foreground (args :foreground)
       .background (args :background)
       .shadows (args :shadows)
       .fontFeatures (args :font-features)
       .fontVariations (args :font-variations)
       .decoration (args :decoration)
       .decorationColor (args :decoration-color)
       .decorationStyle (args :decoration-style)
       .decorationThickness (args :decoration-thickness)
       .debugLabel (args :debug-label)
       .fontFamily (:family args (:font-family args))
       .fontFamilyFallback (args :font-family-fallback)
       .package (args :package)
       .overflow (args :overflow))

      :else
      (throw (Exception. (str "Invalid text style: " args))))))

(defn ^m/InlineSpan text-span
  "An immutable span of text.

   A TextSpan object can be styled using its style property. The style will be applied to the text and the children.

   A TextSpan object can just have plain text, or it can have children TextSpan objects with their own styles that (possibly only partially) override the style of this object.
   If a TextSpan has both text and children, then the text is treated as if it was an un-styled TextSpan at the start of the children list.
   Leaving the TextSpan.text field null results in the TextSpan acting as an empty node in the InlineSpan tree with a list of children.

   To paint a TextSpan on a Canvas, use a TextPainter. To display a text span in a widget, use a `text`.

   The function accepts:
   - An optional text as the first argument.
   - An optional style map as the first or second argument.
   - An optional map of arguments as the first or second argument. The map can contain the following keys:
     - `:text` (any, default: nil): The text to display.
     - `:style` (map, default: nil): The style to apply to the text.
     - `:children` (list of InlineSpan, default: nil): The children of the text span.
     - `:recognizer` (GestureRecognizer, default: nil): The gesture recognizer to use for this span of text.
     - `:mouse-cursor` (MouseCursor, default: nil): The mouse cursor to use for this span of text.
     - `:on-enter` (function, default: nil): The callback function to be called when the mouse enters this span of text.
     - `:on-exit` (function, default: nil): The callback function to be called when the mouse exits this span of text.
     - `:semantics-label` (string, default: nil): The semantics label to use for this span of text.
     - `:locale` (Locale, default: nil): The locale to use for this span of text.
     - `:spell-out` (bool, default: nil): Whether to spell out the text. 
   - Any remaining arguments are treated as children unless children are defined in the arguments map.
   Children can be InlineSpan objects or any value that will be converted to a string.

    Examples:
   ```clojure
    (text-span \"Hello, \" {:color :red})
    (text-span {:font-wight :bold}
               \"Hello, \" 
               (text-span {:text \"World!\" :style {:color :blue}}))
    (text-span {:text \"Hello, \" :style {:color :red}})
   ```"
  [& value]
  (if (and (= (count value) 1) (instance? m/InlineSpan (first value)))
    (first value)
    (let [a0 (first value)
          a1 (second value)
          first-is-text (not (or (map? a0) (instance? m/InlineSpan a0) (vector? a0)))
          args (some #(when (map? %) %) [a0 a1 {}])
          text (if first-is-text a0 (args :text))
          style (get args :style args)
          children (->> (cond
                          (contains? args :children) (args :children)
                          (map? a1) (drop 2 value)
                          (or (map? a0) first-is-text) (rest value)
                          :else value)
                        (flatten)
                        (filter some?)
                        (map #(if (instance? m/InlineSpan %)
                                %
                                (m/TextSpan .text (str %)))))]
      (m/TextSpan
       .text (str text)
       .children (if (empty? children) nil children)
       .style (some-> style text-style)
       .recognizer (args :recognizer)
       .mouseCursor (args :mouse-cursor)
       .onEnter (args :on-enter)
       .onExit (args :on-exit)
       .semanticsLabel (args :semantics-label)
       .locale (some-> args :locale locale)
       .spellOut (args :spell-out)))))

(defn ^m/InlineSpan widget-span
  ([child]
   (cond
     (instance? m/InlineSpan child) child
     (instance? m/Widget child) (widget-span {} child)
     :else (widget-span child (child :child))))
  ([args child]
   (m/WidgetSpan
    .alignment (placeholder-alignment (get args :alignment m/Alignment.center))
    .baseline (some-> args :baseline text-baseline)
    .style (some-> args :style text-style)
    .child child)))

(defn ^m/TileMode tile-mode [mode]
  (if (instance? m/TileMode mode)
    mode
    (case mode
      :clamp m/TileMode.clamp
      :repeated m/TileMode.repeated
      :mirror m/TileMode.mirror
      :decal m/TileMode.decal
      (throw (Exception. (str "Invalid tile-mode: " mode))))))

(defn- gradient-colors [colors]
  (cond
    (nil? colors) [:transparent :transparent]

    (or (vector? colors) (seq? colors))
    (map color
         (case (count colors)
           0 [:transparent :transparent]
           1 [(colors 0) (colors 0)]
           colors))

    :else
    (map color [colors colors])))

(defn- tile-mode-id ^int [mode]
  (case mode
    :clamp 0
    :repeated 1
    :mirror 2
    :decal 3
    0))

(defn- set-gradient-uniforms!
  [^ui/FragmentShader shader
   ^ui/Rect rect
   ^int gradient-type
   ^int tile-mode-id
   colors
   stops
   ^double p0x ^double p0y
   ^double p1x ^double p1y]
  (let [n (count colors)]
    ;; Size
    (.setFloat shader 0 (.-width rect))
    (.setFloat shader 1 (.-height rect))
    ;; Type & tile mode
    (.setFloat shader 2 (double gradient-type))
    (.setFloat shader 3 (double tile-mode-id))
    ;; Color count
    (.setFloat shader 4 (double n))
    ;; Geometry
    (.setFloat shader 5 p0x)
    (.setFloat shader 6 p0y)
    (.setFloat shader 7 p1x)
    (.setFloat shader 8 p1y)
    ;; Colors (indices 9..72, 16 slots × 4 components)
    (dotimes [i 16]
      (let [base (+ 9 (* i 4))]
        (if (< i n)
          (let [^ui/Color c (nth colors i)]
            (.setFloat shader base (/ (.-red c) 255.0))
            (.setFloat shader (+ base 1) (/ (.-green c) 255.0))
            (.setFloat shader (+ base 2) (/ (.-blue c) 255.0))
            (.setFloat shader (+ base 3) (.-opacity c)))
          (do
            (.setFloat shader base 0.0)
            (.setFloat shader (+ base 1) 0.0)
            (.setFloat shader (+ base 2) 0.0)
            (.setFloat shader (+ base 3) 0.0)))))
    ;; Stops (indices 73..88)
    (dotimes [i 16]
      (.setFloat shader (+ 73 i)
                (if (< i n) (double (nth stops i)) 1.0)))
    shader))

(deftype OkLabGradient
  [colors stops
   ^int gradient-type
   ^int tm-id
   begin-align end-align
   center-align
   ^double radius-val
   ^double start-angle ^double end-angle]
  :extends (m/Gradient .colors colors .stops stops)

  (createShader [this ^ui/Rect rect ^ui/TextDirection? .textDirection]
    (let [shader (shader/create-oklab-shader)
          stops (or (.-stops this)
                    (let [n (count colors)]
                      (mapv #(/ (double %) (dec n)) (range n))))]
      (case gradient-type
        ;; Linear
        0 (let [b (.withinRect (.resolve ^m/AlignmentGeometry begin-align textDirection) rect)
                e (.withinRect (.resolve ^m/AlignmentGeometry end-align textDirection) rect)]
            (set-gradient-uniforms! shader rect 0 tm-id colors stops
                                   (.-dx b) (.-dy b) (.-dx e) (.-dy e)))
        ;; Radial
        1 (let [c (.withinRect (.resolve ^m/AlignmentGeometry center-align textDirection) rect)
                r (* radius-val (.-shortestSide rect))]
            (set-gradient-uniforms! shader rect 1 tm-id colors stops
                                   (.-dx c) (.-dy c) r 0.0))
        ;; Sweep
        2 (let [c (.withinRect (.resolve ^m/AlignmentGeometry center-align textDirection) rect)]
            (set-gradient-uniforms! shader rect 2 tm-id colors stops
                                   (.-dx c) (.-dy c) start-angle end-angle)))))

  (scale [this ^double factor]
    (OkLabGradient
     (mapv #(.withOpacity ^ui/Color % (* (.-opacity ^ui/Color %) factor)) colors)
     stops gradient-type tm-id
     begin-align end-align center-align radius-val start-angle end-angle)))

(defn ^m/Gradient linear-gradient
  "Creates a LinearGradient object from the specified arguments.
   The arguments can be specified as a map with the following keys:
   - `:begin` (alignment, default: :center-start): The alignment of the gradient's start point.
   - `:end` (alignment, default: :center-end): The alignment of the gradient's end point.
   - `:colors` (list of colors, default: [:transparent :transparent]): The colors of the gradient.
   - `:stops` (list of numbers, default: nil): The stops of the gradient.
   - `:tile-mode` (tile-mode, default: :clamp): The tile mode of the gradient.
   - `:color-space` (keyword, default: :oklab): `:oklab` for perceptual interpolation, `:srgb` for native."
  [arg0 & args]
  (let [args (if (empty? args) arg0 (apply hash-map (cons arg0 args)))]
    (cond
      (instance? m/Gradient args)
      args

      (map? args)
      (let [cs (:color-space args :oklab)
            colors (vec (gradient-colors (:colors args)))
            stops (:stops args)
            tm (:tile-mode args :clamp)
            begin (alignment-geometry (:begin args m/AlignmentDirectional.centerStart))
            end (alignment-geometry (:end args m/AlignmentDirectional.centerEnd))]
        (if (and (= cs :oklab) (shader/oklab-shader-loaded?))
          (OkLabGradient colors stops 0 (tile-mode-id tm)
                         begin end nil 0.0 0.0 0.0)
          (let [[colors stops] (ut/expand-gradient-colors
                                cs colors stops (:steps args 16))]
            (m/LinearGradient
             .begin begin .end end
             .colors colors .stops stops
             .tileMode (tile-mode tm)))))

      :else
      (throw (Exception. (str "Invalid LinearGradient: " args))))))

(defn ^m/Gradient sweep-gradient
  "Creates a SweepGradient object from the specified arguments.
   The arguments can be specified as a map with the following keys:
   - `:center` (alignment, default: :center): The alignment of the gradient's center point.
   - `:start-angle` (number, default: 0): The start angle of the gradient.
   - `:end-angle` (number, default: 2 * Math/PI): The end angle of the gradient.
   - `:colors` (list of colors, default: [:transparent :transparent]): The colors of the gradient.
   - `:stops` (list of numbers, default: nil): The stops of the gradient.
   - `:tile-mode` (tile-mode, default: :clamp): The tile mode of the gradient.
   - `:color-space` (keyword, default: :oklab): `:oklab` for perceptual interpolation, `:srgb` for native."
  [arg0 & args]
  (let [args (if (empty? args) arg0 (apply hash-map (cons arg0 args)))]
    (cond
      (instance? m/Gradient args)
      args

      (map? args)
      (let [cs (:color-space args :oklab)
            colors (vec (gradient-colors (:colors args)))
            stops (:stops args)
            tm (:tile-mode args :clamp)
            center (alignment-geometry (:center args m/Alignment.center))
            sa (double (:start-angle args 0))
            ea (double (:end-angle args (* 2 (.pi double))))]
        (if (and (= cs :oklab) (shader/oklab-shader-loaded?))
          (OkLabGradient colors stops 2 (tile-mode-id tm)
                         nil nil center 0.0 sa ea)
          (let [[colors stops] (ut/expand-gradient-colors
                                cs colors stops (:steps args 16))]
            (m/SweepGradient
             .center center
             .startAngle sa .endAngle ea
             .colors colors .stops stops
             .tileMode (tile-mode tm)))))

      :else
      (throw (Exception. (str "Invalid SweepGradient: " args))))))

(defn ^m/Gradient radial-gradient
  "Creates a RadialGradient object from the specified arguments.
   The arguments can be specified as a map with the following keys:
   - `:center` (alignment, default: Alignment.center): The alignment of the gradient's center point.
   - `:radius` (number, default: 0.5): The radius of the gradient.
   - `:colors` (list of colors, default: [:transparent :transparent]): The colors of the gradient.
   - `:stops` (list of numbers, default: nil): The stops of the gradient.
   - `:tile-mode` (tile-mode, default: :clamp): The tile mode of the gradient.
   - `:color-space` (keyword, default: :oklab): `:oklab` for perceptual interpolation, `:srgb` for native."
  [arg0 & args]
  (let [args (if (empty? args) arg0 (apply hash-map (cons arg0 args)))]
    (cond
      (instance? m/Gradient args)
      args

      (map? args)
      (let [cs (:color-space args :oklab)
            colors (vec (gradient-colors (:colors args)))
            stops (:stops args)
            tm (:tile-mode args :clamp)
            center (alignment-geometry (:center args m/Alignment.center))
            r (double (:radius args 0.5))]
        (if (and (= cs :oklab) (shader/oklab-shader-loaded?))
          (OkLabGradient colors stops 1 (tile-mode-id tm)
                         nil nil center r 0.0 0.0)
          (let [[colors stops] (ut/expand-gradient-colors
                                cs colors stops (:steps args 16))]
            (m/RadialGradient
             .center center .radius r
             .colors colors .stops stops
             .tileMode (tile-mode tm)))))

      :else
      (throw (Exception. (str "Invalid RadialGradient: " args))))))

(defn- set-mesh-uniforms!
  [^ui/FragmentShader shader
   ^ui/Rect rect
   ^int grid-w ^int grid-h
   points colors]
  (let [n (* grid-w grid-h)]
    ;; Size
    (.setFloat shader 0 (.-width rect))
    (.setFloat shader 1 (.-height rect))
    ;; Grid dimensions
    (.setFloat shader 2 (double grid-w))
    (.setFloat shader 3 (double grid-h))
    ;; Positions (indices 4..131, 64 slots × 2 components)
    (dotimes [i 64]
      (let [base (+ 4 (* i 2))]
        (if (< i n)
          (let [pt (nth points i)]
            (.setFloat shader base (double (nth pt 0)))
            (.setFloat shader (+ base 1) (double (nth pt 1))))
          (do
            (.setFloat shader base 0.0)
            (.setFloat shader (+ base 1) 0.0)))))
    ;; Colors (indices 132..387, 64 slots × 4 components)
    (dotimes [i 64]
      (let [base (+ 132 (* i 4))]
        (if (< i n)
          (let [^ui/Color c (nth colors i)]
            (.setFloat shader base (/ (.-red c) 255.0))
            (.setFloat shader (+ base 1) (/ (.-green c) 255.0))
            (.setFloat shader (+ base 2) (/ (.-blue c) 255.0))
            (.setFloat shader (+ base 3) (.-opacity c)))
          (do
            (.setFloat shader base 0.0)
            (.setFloat shader (+ base 1) 0.0)
            (.setFloat shader (+ base 2) 0.0)
            (.setFloat shader (+ base 3) 0.0)))))
    shader))

(deftype OkLabMeshGradient
  [colors ^int grid-w ^int grid-h points]
  :extends (m/Gradient .colors colors .stops nil)

  (createShader [this ^ui/Rect rect ^ui/TextDirection? .textDirection]
    (let [shader (shader/create-mesh-shader)]
      (set-mesh-uniforms! shader rect grid-w grid-h points colors)))

  (scale [this ^double factor]
    (OkLabMeshGradient
     (mapv #(.withOpacity ^ui/Color % (* (.-opacity ^ui/Color %) factor)) colors)
     grid-w grid-h points)))

(defn- default-mesh-points [^int w ^int h]
  (let [max-col (dec w)
        max-row (dec h)]
    (vec (for [row (range h)
               col (range w)]
           [(/ (double col) max-col)
            (/ (double row) max-row)]))))

(defn ^m/Gradient mesh-gradient
  "Creates a mesh gradient defined by a grid of control points with colors.
   Colors are interpolated in OKLab color space for perceptual uniformity.

   - `:width` (int, required): grid columns (>= 2, max 8)
   - `:height` (int, required): grid rows (>= 2, max 8)
   - `:colors` (vector of colors, required): one color per grid point, row-major
   - `:points` (vector of [x y], optional): positions in [0,1] space, row-major.
     Defaults to a regular evenly-spaced grid.

   ```clojure
   (mesh-gradient {:width 3 :height 3
                   :colors [:red :orange :yellow
                            :green :white :blue
                            :purple :pink :cyan]})
   ```"
  [arg0 & args]
  (let [args (if (empty? args) arg0 (apply hash-map (cons arg0 args)))]
    (cond
      (instance? m/Gradient args)
      args

      (map? args)
      (let [w (int (:width args))
            h (int (:height args))
            n (* w h)
            colors (vec (map color (:colors args)))
            points (or (:points args) (default-mesh-points w h))]
        (assert (>= w 2) "mesh-gradient: width must be >= 2")
        (assert (>= h 2) "mesh-gradient: height must be >= 2")
        (assert (<= n 64) "mesh-gradient: grid too large (max 64 points = 8x8)")
        (assert (= (count colors) n) "mesh-gradient: colors count must equal width * height")
        (assert (= (count points) n) "mesh-gradient: points count must equal width * height")
        (if (shader/mesh-shader-loaded?)
          (OkLabMeshGradient colors w h points)
          (m/LinearGradient
           .begin m/Alignment.topLeft .end m/Alignment.bottomRight
           .colors [(first colors) (last colors)]
           .stops [0.0 1.0])))

      :else
      (throw (Exception. (str "Invalid mesh-gradient: " args))))))

(defn ^m/Gradient gradient
  "Creates a Gradient object from the specified gradient.
   The gradient can be specified as a Gradient object, a map with the following keys:
   - `:begin` (alignment, default: :center-start): The alignment of the linear gradient's start point.
   - `:end` (alignment, default: :center-end): The alignment of the linear gradient's end point.
   - `:start-angle` (number, default: 0): The start angle of the sweep gradient.
   - `:end-angle` (number, default: 2 * Math/PI): The end angle of the sweep gradient.
   - `:radius` (number, default: 0.5): The radius of the radial gradient."
  [gradient]
  (cond
    (instance? m/Gradient gradient) gradient
    (some #(contains? gradient %) [:width :height]) (mesh-gradient gradient)
    (some #(contains? gradient %) [:begin :end]) (linear-gradient gradient)
    (some #(contains? gradient %) [:start-angle :end-angle]) (sweep-gradient gradient)
    (some #(contains? gradient %) [:radius]) (radial-gradient gradient)
    :else (throw (Exception. (str "Unknown gradient: " gradient)))))

(defn shape
  "Creates a Shape object from the specified shape.
   The shape can be specified as a Shape object, a map with the following keys:
   - `:circle` (number, default: nil): The radius of the circle.
   - `:rectangle` or `:rect` (number, default: nil): The radius of the rectangle."
  [shape]
  (cond
    (instance? m/BoxShape shape) shape
    (instance? m/ShapeBorder shape) shape

    :else
    (case shape
      :circle m/BoxShape.circle
      (:rectangle :rect) m/BoxShape.rectangle
      m/BoxShape.rectangle)))

(defn ^m/Radius radius
  "Creates a Radius object from the specified radius.
   The radius can be specified as a number, a map of x and y, or a XY sequence.
   Examples:
   ```clojure
   (radius 4) ;; Radius.circular(4)
   (radius {:x 4 :y 8}) ;; Radius.elliptical(4, 8)
   (radius [4 8]) ;; Radius.elliptical(4, 8)
   ```"
  [arg0 & args]
  (let [radius (cond
                 (empty? args) arg0
                 (keyword? arg0) (apply hash-map (cons arg0 args))
                 :else (cons arg0 args))]
    (cond
      (instance? m/Radius radius) radius
      (number? radius) (m/Radius.circular radius)
      (map? radius) (m/Radius.elliptical (get radius :x 0) (get radius :y 0))
      (or (seq? radius) (vector? radius)) (m/Radius.elliptical (get radius 0 0) (get radius 1 0))
      :else (throw (Exception. (str "Invalid radius: " radius))))))

(defn ^m/BorderRadiusGeometry border-radius
  "Creates a BorderRadius object from the specified radius.
   The radius can be specified as a radius. or a map of corner names to a radius.
   Each corner can be specified separately using the keys `:top-left`, `:top-right`, `:bottom-left`, `:bottom-right`, `:left-top`, `:right-top`, `:left-bottom`, `:right-bottom`, `:left`, `:right`, `:top`, `:bottom`, `:start`, `:end`, `:t`, `:b`, `:l`, `:r`, `:s`, `:e`, `:all`.
   Each radius can be specified as a number or a map of x and y or a XY sequence.
   Examples:
   ```clojure
   (border-radius 4) ;; BorderRadius.all(Radius.circular(4))
   (border-radius {:top-left 4 :top-right 8}) ;; BorderRadius.only(topLeft: Radius.circular(4), topRight: Radius.circular(8))
   (border-radius {:l 4 :r 8}) ;; BorderRadius.only(topLeft: Radius.circular(4), topRight: Radius.circular(8), bottomLeft: Radius.circular(4), bottomRight: Radius.circular(8))
   (border-radius {:x 4 :y 8}) ;; BorderRadius.all(Radius.elliptical(4, 8))
   (border-radius [4 8]) ;; BorderRadius.all(Radius.elliptical(4, 8))
   (border-radius {:top-left 4 :all 8}) ;; BorderRadius.only(topLeft: Radius.circular(4), topRight: Radius.circular(8), bottomLeft: Radius.circular(8), bottomRight: Radius.circular(8))
   ```"
  [arg0 & args]
  (let [value (cond
                (empty? args) arg0
                (keyword? arg0) (apply hash-map (cons arg0 args))
                :else (vec (cons arg0 args)))]
    (cond
      (instance? m/BorderRadiusGeometry value) value
      (or (number? value) (instance? m/Radius value) (seq? value) (vector? value)) (m/BorderRadius.all (radius value))

      (map? value)
      (cond
        (some? (some value [:x :y])) (m/BorderRadius.all (radius value))

        (some? (some value [:l :r :left :right :top-left :top-right :bottom-left :bottom-right :left-top :right-top :left-bottom :right-bottom]))
        (m/BorderRadius.only
         .topLeft (radius (or (some value [:top-left :left-top :top :left :l :t :all]) 0))
         .topRight (radius (or (some value [:top-right :right-top :top :right :r :t :all]) 0))
         .bottomLeft (radius (or (some value [:bottom-left :left-bottom :bottom :left :l :b :all]) 0))
         .bottomRight (radius (or (some value [:bottom-right :right-bottom :bottom :right :r :b :all]) 0)))

        :else
        (m/BorderRadiusDirectional.only
         .topStart (radius (or (some value [:top-start :start-top :top :start :s :t :all]) 0))
         .topEnd (radius (or (some value [:top-end :end-top :top :end :e :t :all]) 0))
         .bottomStart (radius (or (some value [:bottom-start :start-bottom :bottom :start :s :b :all]) 0))
         .bottomEnd (radius (or (some value [:bottom-end :end-bottom :bottom :end :e :b :all]) 0))))

      :else (throw (Exception. (str "Invalid radius: " value))))))

(defn ^m/Decoration decoration
  "Creates a Decoration object from the specified arguments.
   The arguments can be specified as a Decoration objects or a key-values pairs with the following keys:
    - `:shape` (ShapeBorder or BoxShape or a keyword default: nil): The shape of the decoration.
    - `:color` (Color, default: nil): The color of the decoration.
    - `:image` (ImageProvider, default: nil): The image of the decoration.
    - `:gradient` (Gradient, default: nil): The gradient of the decoration.
    - `:border` (Border, default: nil): The border of the decoration.
    - `:border-radius` (BorderRadius, default: nil): The border radius of the decoration.
    - `:box-shadow` or `:shadow` or `:shadows` (BoxShadow or list of BoxShadow, default: nil): The box shadow of the decoration.
    - `:background-blend-mode` (BlendMode, default: nil): The background blend mode of the decoration.

    Examples:
    ```clojure
    (decoration :color :red)
    (decoration {:shape :circle, :color :red})
    (decoration {:shape :circle, :color :red, :border-radius 4})
    ```"
  [arg0 & args]
  (let [args (if (empty? args) arg0 (apply hash-map (cons arg0 args)))
        shape (shape (args :shape))]
    (cond
      (instance? m/Decoration args) args

      (instance? m/ShapeBorder shape)
      (m/ShapeDecoration
       .color (some-> (args :color) color)
       .image (args :image)
       .gradient (some-> (args :gradient) gradient)
       .shadows (some args [:box-shadow :shadows :shadow])
       .shape shape)

      (instance? m/BoxShape shape)
      (m/BoxDecoration
       .color (some-> (args :color) color)
       .image (args :image)
       .border (args :border)
       .borderRadius (some-> (args :border-radius) border-radius)
       .boxShadow (some args [:box-shadow :shadows :shadow])
       .gradient (some-> (args :gradient) gradient)
       .backgroundBlendMode (args :background-blend-mode)
       .shape shape)

      :else (throw (Exception. (str "Invalid decoration: " args))))))

(defn ^dc/Duration duration
  "Creates a Duration object from the specified value.
   The value can be specified as a number, a map of days, hours, minutes, seconds, milliseconds, microseconds, or a Duration object.
   Examples:
   ```clojure
   (duration 500) ;; Duration(milliseconds: 500)
   (duration {:seconds 30}) ;; Duration(seconds: 30)
   (duration {:days 1 :hours 2 :minutes 30}) ;; Duration(days: 1, hours: 2, minutes: 30)
   (duration (dc/Duration .seconds 30)) ;; Duration(seconds: 30)
   ```"
  [arg0 & args]
  (let [value (if (empty? args) arg0 (apply hash-map (cons arg0 args)))]
    (cond
      (instance? dc/Duration value) value
      (integer? value) (dc/Duration .milliseconds value)
      (number? value) (dc/Duration .microseconds (int (* value 1000.0)))
      (map? value) (dc/Duration
                    .days (int (:d value (:day value 0)))
                    .hours (int (:h value (:hours value 0)))
                    .minutes (int (:m value (:minutes value 0)))
                    .seconds (int (:s value (:seconds value 0)))
                    .milliseconds (int (:ms value (:milliseconds value 0)))
                    .microseconds (int (:μs value (:microseconds value 0))))
      (nil? value) nil
      :else (throw (Exception. (str "Invalid duration: " value))))))

(deftype AnyCurve
         [curve description]
  :extends (a/Curve)
  (transform [_ t] (double (curve t)))
  (toString [_] (str (or (when description (description)) "AnyCurve"))))

(defn ^m/Curve curve [curve]
  (cond
    (instance? m/Curve curve) curve

    (keyword? curve)
    (case curve
      :linear a/Curves.linear
      :bounce-in a/Curves.bounceIn
      :bounce-in-out a/Curves.bounceInOut
      :bounce-out a/Curves.bounceOut
      :decelerate a/Curves.decelerate
      :ease a/Curves.ease
      :ease-in a/Curves.easeIn
      :ease-in-back a/Curves.easeInBack
      :ease-in-circ a/Curves.easeInCirc
      :ease-in-cubic a/Curves.easeInCubic
      :ease-in-expo a/Curves.easeInExpo
      :ease-in-out a/Curves.easeInOut
      :ease-in-out-back a/Curves.easeInOutBack
      :ease-in-out-circ a/Curves.easeInOutCirc
      :ease-in-out-cubic a/Curves.easeInOutCubic
      :ease-in-out-cubic-emphasized a/Curves.easeInOutCubicEmphasized
      :ease-in-out-expo a/Curves.easeInOutExpo
      :ease-in-out-quad a/Curves.easeInOutQuad
      :ease-in-out-quart a/Curves.easeInOutQuart
      :ease-in-out-quint a/Curves.easeInOutQuint
      :ease-in-out-sine a/Curves.easeInOutSine
      :ease-in-quad a/Curves.easeInQuad
      :ease-in-quart a/Curves.easeInQuart
      :ease-in-quint a/Curves.easeInQuint
      :ease-in-sine a/Curves.easeInSine
      :ease-in-to-linear a/Curves.easeInToLinear
      :ease-out a/Curves.easeOut
      :ease-out-back a/Curves.easeOutBack
      :ease-out-circ a/Curves.easeOutCirc
      :ease-out-cubic a/Curves.easeOutCubic
      :ease-out-expo a/Curves.easeOutExpo
      :ease-out-quad a/Curves.easeOutQuad
      :ease-out-quart a/Curves.easeOutQuart
      :ease-out-quint a/Curves.easeOutQuint
      :ease-out-sine a/Curves.easeOutSine
      :elastic-in a/Curves.elasticIn
      :elastic-in-out a/Curves.elasticInOut
      :elastic-out a/Curves.elasticOut
      :fast-ease-in-to-slow-ease-out a/Curves.fastEaseInToSlowEaseOut
      :fast-linear-to-slow-ease-in a/Curves.fastLinearToSlowEaseIn
      :fast-out-slow-in a/Curves.fastOutSlowIn
      :slow-middle a/Curves.slowMiddle
      (throw (Exception. (str "Unknown curve: " curve))))

    (fn? curve) (AnyCurve curve nil)

    :else
    (throw (Exception. (str "Invalid curve: " curve)))))

(def ^:dynamic *anim-ctx* {:animation {:duration (dc/Duration .milliseconds 250) :curve a/Curves.easeInOut}
                           :animate #(%)
                           :is-animated? false})

(defn animation-options
  "Creates an animation options object from the specified value.
   The value can be specified as a map with the following keys:
   - `:duration` or `:dur` (number, map or Duration, default: 250): The duration of the animation in milliseconds.
   - `:curve` (keyword, fn or Curve, default: :linear): The curve of the animation.
   - `:on-end` (function, default: nil): The callback function to be called when the animation ends.
   The value can also be specified as a vector with the following elements:
   - The duration of the animation.
   - The curve of the animation.
   - The callback function to be called when the animation ends.
   The value can also be specified as a number, in which case it is used as the duration of the animation."
  [arg0 & args]
  (let [value (if (empty? args) arg0 (apply hash-map (cons arg0 args)))
        def-curve (get-in *anim-ctx* [:animation :curve] a/Curves.linear)]
    (cond
      (map? value)
      (let [duration (duration (:duration value (:dur value (get-in *anim-ctx* [:animation :duration]))))
            curve (curve (:curve value def-curve))
            on-end (value :on-end)]
        {:duration duration :curve curve :on-end on-end})

      (number? value)
      {:duration (duration value) :curve def-curve}

      (or (vector? value) (seq? value))
      (let [duration (duration (get value 0))
            curve (curve (get value 1 def-curve))
            on-end (get value 2)]
        {:duration duration :curve curve :on-end on-end})

      :else
      (throw (Exception. (str "Invalid animation options: " value))))))

(defn ^m/Key? widget-key
  "Creates a `WidgetKey` object from the specified key.
   The key can be specified as a string, a keyword, a number, or a `WidgetKey` object.
   If the key is a string or a keyword, it is converted to a `ValueKey` object.
   If the key is a number, it is converted to a `ValueKey` object.
   If the key is a `WidgetKey` object, it is returned as-is."
  [key]
  (cond
    (nil? key) nil
    (instance? m/Key key) key
    :else (m/ValueKey key)))

(defn ^f/CustomTween tween
  ([lerp-fn from to]
   (doto (f/CustomTween (or lerp-fn #(ut/lerp %1 %2)) nil)
     (.-begin! from)
     (.-end! to)))
  ([from to]
   (tween nil from to)))

(defn ^s/LogicalKeyboardKey logical-keyboard-key
  "Converts a given `key` into a `LogicalKeyboardKey` instance.
   If `key` is already a `LogicalKeyboardKey` instance, it is returned as-is.
   Otherwise, it attempts to resolve the `key` by converting it to a string, 
   then finding the corresponding `LogicalKeyboardKey` based on the first character.
   Returns nil if the lookup fails."
  [key]
  (cond
    (instance? s/LogicalKeyboardKey key) key
    (int? key) (s/LogicalKeyboardKey key)
    :else
    (keys/logical-keyboard-keys
     (str/lower-case (if (keyword? key) (name key) (str key))))))

(defn- one-char?
  "Checks if the `value` is a single character.
   Returns true if `value` is a char, a single-character string, 
   or a digit (0-9); otherwise, returns false."
  [value]
  (or
   (char? value)
   (and (string? value) (= (count value) 1))
   (and (int? value) (<= 0 value 9))))

(def ^:private modifier-keys-ids
  "Set of key IDs corresponding to modifier keys: control, shift, alt, and meta."
  (set (map #(.-keyId %) [s/LogicalKeyboardKey.control
                          s/LogicalKeyboardKey.shift
                          s/LogicalKeyboardKey.alt
                          s/LogicalKeyboardKey.meta])))

(defn ^m/ShortcutActivator shortcut-activator
  "Creates a `ShortcutActivator` based on the given `args`.
   If `args` is already a `ShortcutActivator`, it is returned directly.
   If `args` is a single character, creates a `CharacterActivator`.
   If `args` is a string, keyword, integer, vector, or sequence, processes it 
   to generate appropriate modifier and trigger key sets, then constructs 
   either a `CharacterActivator`, `SingleActivator`, or `LogicalKeySet` based on the input.

   Args can contain an additional map with the following keys:
    - `:include-repeats` (boolean, default: true): Whether to include repeated key events.

   Throws an exception if `args` is invalid."
  [args]
  (cond
    (instance? m/ShortcutActivator args) args

    (one-char? args) (m/CharacterActivator (str args))

    (or (keyword? args) (string? args) (int? args)) (shortcut-activator [args])

    (or (vector? args) (seq? args))
    (let [keys (set (filter some? (map logical-keyboard-key args)))
          chars (filter one-char? args)
          groups (group-by #(contains? modifier-keys-ids (.-keyId %)) keys)
          modifiers (set (get groups true `()))
          triggers (set (get groups false `()))
          alt (some? (some #(= (.-keyId s/LogicalKeyboardKey.alt) (.-keyId %)) modifiers))
          control (some? (some #(= (.-keyId s/LogicalKeyboardKey.control) (.-keyId %)) modifiers))
          shift (some? (some #(= (.-keyId s/LogicalKeyboardKey.shift) (.-keyId %)) modifiers))
          meta (some? (some #(= (.-keyId s/LogicalKeyboardKey.meta) (.-keyId %)) modifiers))
          args (or (some map? args) {})
          include-repeats (:include-repeats args true)]
      (if (and (false? shift) (= (count chars) 1))
        (m/CharacterActivator (str (first chars))
                              .alt alt
                              .control control
                              .meta meta
                              .includeRepeats include-repeats)
        (if (= (count triggers) 1)
          (m/SingleActivator (first triggers)
                             .alt alt
                             .control control
                             .shift shift
                             .meta meta
                             .numLock (lock-state (:num-lock args w/LockState.ignored))
                             .includeRepeats include-repeats)
          (m/LogicalKeySet.fromSet keys))))

    :else
    (throw (Exception. (str "Invalid activator: " args)))))

(defn ^m/BoxConstraints box-constraints
  "Immutable layout constraints for RenderBox layout.

   The functions accepts the following arguments:
    - A BoxConstraints object.
    - A ViewConstraints object.
    - A Size object.
    - A map with the following keys:
      - `:width`, :w, :size (number or a map with :max and :min keys): Width constraints. If a number is provided, it is used as the fixed width of the box. 
      - `:height`, :h, :size (number or a map with :max and :min keys): Height constraints. If a number is provided, it is used as the fixed height of the box.
      - `:min-width`, :min-w, :min-size (number, default: 0): The minimum width of the box.
      - `:max-width`, :max-w, :max-size (number, default: double.infinity): The maximum width of the box.
      - `:min-height`, :min-h, :min-size (number, default: 0): The minimum height of the box.
      - `:max-height`, :max-h, :max-size (number, default: double.infinity): The maximum height of the box.
    - A number or a vector with two numbers or maps representing the width and height of the box.

   ```clojure
   (box-constraints {:min-width 100 :max-width 200 :min-height 50 :max-height 100})
   (box-constraints {:width {:min 100 :max 200} :height {:min 50 :max 100}})
   (box-constraints [100 200])
   (box-constraints 100)
   (box-constraints {:w 100 :h {:max 300}})
   (box-constraints {:min-size 10 :max-size 100})
   ```

   A Size respects a BoxConstraints if, and only if, all of the following relations hold:
      - minWidth <= Size.width <= maxWidth
      - minHeight <= Size.height <= maxHeight

   The constraints themselves must satisfy these relations:
      - 0.0 <= minWidth <= maxWidth <= double.infinity
      - 0.0 <= minHeight <= maxHeight <= double.infinity

   double.infinity is a legal value for each constraint.
   [Flutter docs](https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html)"
  [arg0 & args]
  (let [value (if (empty? args) arg0 (apply hash-map (cons arg0 args)))]
    (cond
      (instance? m/BoxConstraints value) value
      (instance? ui/ViewConstraints value) (m/BoxConstraints.fromViewConstraints value)
      (and (map? value) (:size value)) (box-constraints (:size value))

      (map? value)
      (let [w (some value [:width :w])
            h (some value [:height :h])
            get-cnstrt (fn [value type] (cond
                                          (map? value) (get value type)
                                          (number? value) value
                                          :else nil))
            compute (fn [dim type]
                      (let [type-str (name type)
                            [val names]
                            (case dim
                              :w [w ["width" "w"]]
                              [h ["height" "h"]])
                            [fun edge]
                            (case type
                              :min [max 0.0]
                              [min dc/double.infinity])
                            keys (map #(keyword (str type-str "-" %)) (conj names "size"))]
                        (double (reduce fun (filter some? [(some value keys) (get-cnstrt val type) edge])))))]
        (m/BoxConstraints
         .minWidth (compute :w :min)
         .maxWidth (compute :w :max)
         .minHeight (compute :h :min)
         .maxHeight (compute :h :max)))
      (number? value) (m/BoxConstraints.tightFor .width (double value) .height (double value))
      (vector? value) (box-constraints {:w (get value 0) :h (get value 1 (get value 0))})
      (instance? m/Size value) (m/BoxConstraints.tight value)
      (nil? value) (m/BoxConstraints.tightFor .width nil .height nil)

      :else
      (throw (Exception. (str "Invalid box constraints: " value))))))

(defn ^m/FlexFit flex-fit
  "Converts the specified `fit` value to a `FlexFit` object.\\
   If `fit` is already a `FlexFit` object, it is returned as-is.\\
   If `fit` is a keyword (`:tight` or `:loose`), it is converted to a `FlexFit` object.\\
   If `fit` is not recognized, an exception is thrown."
  [fit]
  (if (instance? m/FlexFit fit) 
    fit
    (case fit
      :tight m/FlexFit.tight
      :loose m/FlexFit.loose
      (throw (Exception. (str "Unknown flex-fit: " fit " (expected FlexFit, :tight, :loose)"))))))

(defn ^a/AnimationBehavior animation-behavior
  "Returns the `AnimationBehavior` enum value for the specified animation behavior.
   
   Configures how an `AnimationController` behaves when animations are disabled.

   When `AccessibilityFeatures.disableAnimations` is true, the device is asking Flutter to reduce or disable animations as much as possible.
   To honor this, we reduce the duration and the corresponding number of frames for animations.
   This enum is used to allow certain `AnimationControllers` to opt out of this behavior.
   For example, the `AnimationController` which controls the physics simulation for a scrollable list will have `AnimationBehavior.preserve`, so that when a user attempts to scroll it does not jump to the end/beginning too quickly.
   
   Possible values:
   - instance of `AnimationBehavior`
   - `:normal` The `AnimationController` will reduce its duration when `AccessibilityFeatures.disableAnimations` is true.
   - `:preserve` The `AnimationController` will preserve its behavior.

   This is the default for repeating animations in order to prevent them from flashing rapidly on the screen if the widget does not take the `AccessibilityFeatures.disableAnimations` flag into account.
   
   [Flutter docs](https://api.flutter.dev/flutter/animation/AnimationBehavior.html)"
  [behavior]
  (if (instance? a/AnimationBehavior behavior)
    behavior
    (case behavior
      :normal a/AnimationBehavior.normal
      :preserve a/AnimationBehavior.preserve
      (throw (Exception. (str "Invalid animation behavior: " behavior))))))

(defn ^a/AnimationStatus animation-status
  "Returns the `AnimationStatus` enum value for the specified animation status.
   
   The status of an animation.

   Possible values:
   - instance of `AnimationStatus`
   - `:dismissed` The animation is stopped at the beginning.
   - `:forward` The animation is running from beginning to end.
   - `:reverse` The animation is running in the reverse direction.
   - `:completed` The animation is stopped at the end.
   
   [Flutter docs](https://api.flutter.dev/flutter/animation/AnimationStatus.html)"
  [status]
  (if (instance? a/AnimationStatus status)
    status
    (case status
      :dismissed a/AnimationStatus.dismissed
      :forward a/AnimationStatus.forward
      :reverse a/AnimationStatus.reverse
      :completed a/AnimationStatus.completed
      (throw (Exception. (str "Invalid animation status: " status))))))

(defn ^a/AlwaysStoppedAnimation always-stopped-animation
  "An animation that is always stopped at a given value.

   The status is always AnimationStatus.forward.

   [Flutter docs](https://api.flutter.dev/flutter/animation/AlwaysStoppedAnimation-class.html)"
  [value]
  (if (instance? a/AlwaysStoppedAnimation value)
    value
    (a/AlwaysStoppedAnimation. value)))

(defn ^ui/AppLifecycleState app-lifecycle-state
  "Converts the specified `state` value to an `AppLifecycleState` object.\\
   If `state` is already an `AppLifecycleState` object, it is returned as-is.\\
   If `state` is a keyword (`:detached`, `:resumed`, `:inactive`, `:hidden`, or `:paused`), it is converted to an `AppLifecycleState` object.\\
   If `state` is not recognized, an exception is thrown.
   
   Possible values:
     - instance of `AppLifecycleState`
     - `:detached` The application is still hosted by a Flutter engine but is detached from any host views.\\ 
       The application defaults to this state before it initializes, and can be in this state (applicable on Android, iOS, and web) after all views have been detached.\\
       When the application is in this state, the engine is running without a view.\\
       This state is only entered on iOS, Android, and web, although on all platforms it is the default state before the application begins running.
     - `:resumed` On all platforms, this state indicates that the application is in the default running mode for a running application that has input focus and is visible.\\
       On Android, this state corresponds to the Flutter host view having focus (Activity.onWindowFocusChanged was called with true) while in Android's \"resumed\" state.\\
       It is possible for the Flutter app to be in the inactive state while still being in Android's \"onResume\" state if the app has lost focus (Activity.onWindowFocusChanged was called with false), but hasn't had Activity.onPause called on it.\\
       On iOS and macOS, this corresponds to the app running in the foreground active state.
     - `:inactive` At least one view of the application is visible, but none have input focus. The application is otherwise running normally.\\
       On non-web desktop platforms, this corresponds to an application that is not in the foreground, but still has visible windows.\\
       On the web, this corresponds to an application that is running in a window or tab that does not have input focus.'\\
       On iOS and macOS, this state corresponds to the Flutter host view running in the foreground inactive state.\\
       Apps transition to this state when in a phone call, when responding to a TouchID request, when entering the app switcher or the control center, or when the UIViewController hosting the Flutter app is transitioning.\\
       On Android, this corresponds to the Flutter host view running in Android's paused state (i.e. Activity.onPause has been called), or in Android's \"resumed\" state (i.e. Activity.onResume has been called) but does not have window focus.\\
       Examples of when apps transition to this state include when the app is partially obscured or another activity is focused, a app running in a split screen that isn't the current app, an app interrupted by a phone call, a picture-in-picture app, a system dialog, another view.\\
       It will also be inactive when the notification window shade is down, or the application switcher is visible.\\
       On Android and iOS, apps in this state should assume that they may be hidden and paused at any time.
     - `:hidden` All views of an application are hidden, either because the application is about to be paused (on iOS and Android), or because it has been minimized or placed on a desktop that is no longer visible (on non-web desktop), or is running in a window or tab that is no longer visible (on the web).\\
       On iOS and Android, in order to keep the state machine the same on all platforms, a transition to this state is synthesized before the paused state is entered when coming from inactive, and before the inactive state is entered when coming from paused.
       This allows cross-platform implementations that want to know when an app is conceptually \"hidden\" to only write one handler.
     - `:paused` The application is not currently visible to the user, and not responding to user input.\\
        When the application is in this state, the engine will not call the PlatformDispatcher.onBeginFrame and PlatformDispatcher.onDrawFrame callbacks.\\
       This state is only entered on iOS and Android."
  [state]
  (if (instance? ui/AppLifecycleState state)
    state
    (case state
      :detached ui/AppLifecycleState.detached
      :resumed ui/AppLifecycleState.resumed
      :inactive ui/AppLifecycleState.inactive
      :hidden ui/AppLifecycleState.hidden
      :paused ui/AppLifecycleState.paused
      (throw (Exception. (str "Invalid app lifecycle state: " state " (expected :detached, :resumed, :inactive, :hidden, or :paused)"))))))

(defn ^r/HitTestBehavior hit-test-behavior
  "Converts the specified value to an `HitTestBehavior` object.
   
   Possible values:
     - instance of `HitTestBehavior`
     - `:defer-to-child` Targets that defer to their children receive events within their bounds only if one of their children is hit by the hit test.
     - `:opaque` Opaque targets can be hit by hit tests, causing them to both receive events within their bounds and prevent targets visually behind them from also receiving events.
     - `:translucent` Translucent targets both receive events within their bounds and permit targets visually behind them to also receive events."
  [value]
  (if (instance? r/HitTestBehavior value)
    value
    (case value
      :defer-to-child r/HitTestBehavior.deferToChild
      :opaque r/HitTestBehavior.opaque
      :translucent r/HitTestBehavior.translucent
      (throw (Exception. (str "Invalid hit test behavior: " value " (expected :defer-to-child, :opaque, :inactive, :translucent)"))))))

(defn ^ui/Size size
  "Creates a new `Size` object with the given width and height.

  Arity:
  1. [w h] - Creates a `Size` object with the specified width and height.
  2. [value] - Creates a `Size` object based on the provided value. The value can be:
     - An instance of `Size`, in which case the same `Size` object is returned.
     - A number, in which case a square `Size` object is created with the value as both width and height.
     - A map, in which case the width and height are extracted from the map using the keys `:w`, `:width`, or `:size` for width, and `:h`, `:height`, or `:size` for height.
     - A vector or seq, in which case the first and second elements are used as width and height respectively.
     - An instance of `Offset` or `Point`, in which case the x/dx and y/dy values are used as width and height respectively.
   ```clojure
   (size 100 200) ;; Size(100.0, 200.0)
   (size 100) ;; Size(100.0, 100.0)
   (size {:w 100 :h 200}) ;; Size(100.0, 200.0)
   ```"
  ([w h] (ui/Size (double w) (double h)))
  ([value]
   (cond
     (instance? ui/Size value) value
     (number? value) (size value value)
     (map? value) (size (or (some value [:w :width :size]) 0) (or (some value [:h :height :size]) 0))
     (or (vector? value) (seq? value)) (size (get value 0 0) (get value 1 0))
     (instance? ui/Offset value) (size (.-dx value) (.-dy value))
     (instance? math/Point value) (size (.-x value) (.-y value))
     :else (throw (Exception. (str "Invalid size: " value))))))

(defn ^ui/Offset offset
  "Creates a new `Offset` object with the given dx and dy.
   
   Arity:
   1. [dx dy] - Creates an `Offset` object with the specified dx and dy.
   2. [value] - Creates an `Offset` object based on the provided value. The value can be:
      - An instance of `Offset`, in which case the same `Offset` object is returned.
      - A number, in which case a square `Offset` object is created with the value as both dx and dy
      - A map, in which case the dx and dy are extracted from the map using the keys `:dx`, `:x`, or `:offset` for dx, and `:dy`, `:y`, or `:offset` for dy.
      - A vector or seq, in which case the first and second elements are used as dx and dy respectively.
      - An instance of `Point`, in which case the x and y values are used as dx and dy respectively.
      - An instance of `Size`, in which case the width and height are used as dx and dy respectively.
   ```clojure
   (offset 100 200) ;; Offset(100.0, 200.0)
   (offset {:dx 100 :dy 200}) ;; Offset(100.0, 200.0)
   (offset [100 200]) ;; Offset(100.0, 200.0)
    ```
   "
  ([dx dy] (ui/Offset (double dx) (double dy)))
  ([value]
   (cond
     (instance? ui/Offset value) value
     (number? value) (offset value value)
     (map? value) (offset (or (some value [:dx :x :offset]) 0) (or (some value [:dy :y :offset]) 0))
     (or (vector? value) (seq? value)) (offset (get value 0 0) (get value 1 0))
     (instance? math/Point value) (offset (.-x value) (.-y value))
     (instance? ui/Size value) (offset (.-width value) (.-height value))
     :else (throw (Exception. (str "Invalid offset: " value))))))

(defn ^math/Point point
  "Creates a new `Point` object with the given dx and dy.
   
   Arity:
   1. [x y] - Creates an `Point` object with the specified x and y.
   2. [value] - Creates an `Point` object based on the provided value. The value can be:
      - An instance of `Point`, in which case the same `Point` object is returned.
      - A number, in which case a square `Point` object is created with the value as both x and y
      - A map, in which case the dx and dy are extracted from the map using the keys `:x`, `:dx` or `:offset` for dx, and `:y`, `:dy` or `:offset` for y.
      - A vector or seq, in which case the first and second elements are used as x and y respectively.
      - An instance of `Offset`, in which case the dx and dy values are used as x and y respectively.
      - An instance of `Size`, in which case the width and height are used as dx and dy respectively.
   ```clojure
   (point 100 200) ;; Point(100.0, 200.0)
   (point {:dx 100 :dy 200}) ;; Point(100.0, 200.0)
    ```
   "
  ([x y] (math/Point (double x) (double y)))
  ([value]
   (cond
     (instance? math/Point value) value
     (number? value) (point value value)
     (map? value) (point (or (some value [:x :dx :offset]) 0) (or (some value [:y :dy :offset]) 0))
     (or (vector? value) (seq? value)) (point (get value 0 0) (get value 1 0))
     (instance? ui/Offset value) (point (.-dx value) (.-dy value))
     (instance? ui/Size value) (point (.-width value) (.-height value))
     :else (throw (Exception. (str "Invalid point: " value))))))

(defn ^ui/Rect rect
  "Creates a new `Rect` object with the given center or offset and size.

     Arity:
     1. [center size] - Creates a `Rect` object with the specified center and size.
     2. [l t w h] - Creates a `Rect` object with the specified left, top, width, and height.
     3. [value] - Creates a `Rect` object based on the provided value. The value can be:
        - An instance of `Rect`, in which case the same `Rect` object is returned.
        - A map, in which case the center and size are extracted from the map using the keys `:center` or `:x`/`:y` , and `:size` or `:w`/`:h`/`:width`/`:height` respectively.
          Or the left, top, width, and height are extracted using the keys `:left`/`:l`, `:top`/`:t`, `:width`/`:w`, and `:height`/`:h` respectively.
          Also `:offset` key can be used to specify the left and top values instead of the center.
     ```clojure
     (rect {:center [100 200] :size [300 400]}) ;; Rect.fromCenter(center: Point(100.0, 200.0), width: 300.0, height: 400.0)
     (rect {:offset [100 200] :size [300 400]}) ;; Rect.fromLTWH(100.0, 200.0, 300.0, 400.0)
     (rect [100 200] [300 400]) ;; Rect.fromCenter(center: Point(100.0, 200.0), width: 300.0, height: 400.0)
     (rect [100 200 300 400]) ;; Rect.fromLTWH(100.0, 200.0, 300.0, 400.0)
     (rect (offset 100 200) (size 300 400)) ;; Rect.fromCenter(center: Point(100.0, 200.0), width: 300.0, height: 400.0)
     (rect {:x 100 :y 200} {:w 300 :h 400}) ;; Rect.fromCenter(center: Point(100.0, 200.0), width: 300.0, height: 400.0)
     (rect {:x 100 :y 200 :w 300 :h 400}) ;; Rect.fromCenter(center: Point(100.0, 200.0), width: 300.0, height: 400.0)
     ```
     "
  ([center size] (let [size (t/size size)]
                   (ui/Rect.fromCenter .center (offset center) .width (.-width size) .height (.-height size))))
  ([l t w h] (ui/Rect.fromLTWH (double l) (double t) (double w) (double h)))
  ([value]
   (cond
     (instance? ui/Rect value) value

     (map? value)
     (let [size (get value :size value)
           point (offset (or (some value [:center :offset]) value))]
       (if (contains? value :offset)
         (rect (.-dx point) (.-dy point) (.-width size) (.-height size))
         (rect point size)))

     (or (vector? value) (seq? value))
     (rect (offset (get value 0 [0 0])) (size (get value 1 [0 0])))

     :else (throw (Exception. (str "Invalid rect: " value))))))

(defn ^vec-math/Vector2 vec2
  "Creates a new `Vector2` object with the given x and y values.
   
   [Flutter doc](https://api.flutter.dev/flutter/vector_math_64/Vector2-class.html)"
  ([value]
   (cond
     (instance? vec-math/Vector2 value) value
     (vector? value) (vec-math/Vector2.array (map double value))
     (number? value) (vec-math/Vector2.all (double value))
     :else (throw (Exception. (str "Invalid vector2: " value)))))
  ([x y]
   (vec-math/Vector2 (double x) (double y))))

(defn ^vec-math/Vector3 vec3
  "Creates a new `Vector3` object with the given x, y, and z values.
   
   [Flutter doc](https://api.flutter.dev/flutter/vector_math_64/Vector3-class.html)"
  ([value]
   (cond
     (instance? vec-math/Vector3 value) value
     (vector? value) (vec-math/Vector3.array (map double value))
     (number? value) (vec-math/Vector3.all (double value))
     :else (throw (Exception. (str "Invalid vector3: " value)))))
  ([x y z]
   (vec-math/Vector3 (double x) (double y) (double z))))

(defn ^vec-math/Vector4 vec4
  "Creates a new `Vector4` object with the given x, y, z, and w values.
   
   [Flutter doc](https://api.flutter.dev/flutter/vector_math_64/Vector4-class.html)"
  ([value]
   (cond
     (instance? vec-math/Vector4 value) value
     (vector? value) (vec-math/Vector4.array (map double value))
     (number? value) (vec-math/Vector4.all (double value))
     :else (throw (Exception. (str "Invalid vector4: " value)))))
  ([x y z w]
   (vec-math/Vector4 (double x) (double y) (double z) (double w))))

(defn ^vec-math/Matrix2 mat2
  "Creates a 2x2 matrix from the specified arguments.
   The arguments can be specified as a vector with 4 elements, vector of vectors, or a 4 double values.
   
   [Flutter doc](https://api.flutter.dev/flutter/vector_math_64/Matrix2-class.html)"
  ([arg0 arg1 arg2 arg3]
   (mat2 [arg0 arg1 arg2 arg3]))
  ([value]
   (cond
     (instance? vec-math/Matrix2 value) value
     (vector? value) (vec-math/Matrix2.fromList (map double (flatten value)))
     :else (throw (Exception. (str "Invalid matrix2: " value))))))

(defn ^vec-math/Matrix3 mat3
  "Creates a 3x3 matrix from the specified arguments.
   The arguments can be specified as a vector with 9 elements, vector of vectors, or a 9 double values.
   
   [Flutter doc](https://api.flutter.dev/flutter/vector_math_64/Matrix3-class.html)"
  ([arg0 arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8]
   (mat3 [arg0 arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8]))
  ([value]
   (cond
     (instance? vec-math/Matrix3 value) value
     (vector? value) (vec-math/Matrix3.fromList (map double (flatten value)))
     :else (throw (Exception. (str "Invalid matrix3: " value))))))

(defn ^vec-math/Matrix4 mat4
  "Creates a 4x4 matrix from the specified arguments.
   The arguments can be specified as a vector with 16 elements, vector of vectors, or a 16 double values.
   
   [Flutter doc](https://api.flutter.dev/flutter/vector_math_64/Matrix4-class.html)"
  ([arg0 arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15]
   (mat4 [arg0 arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15]))
  ([arg0 arg1 arg2 arg3]
   (mat4 [arg0 arg1 arg2 arg3]))
  ([value]
   (cond
     (instance? vec-math/Matrix4 value) value
     (vector? value) (vec-math/Matrix4.fromList (map double (flatten value)))
     :else (throw (Exception. (str "Invalid matrix4: " value))))))

(defn ^vec-math/Quaternion quat
  "Creates a new `Quaternion` object with the given x, y, z, and w values.
   
   [Flutter doc](https://api.flutter.dev/flutter/vector_math_64/Quaternion-class.html)"
  ([value]
   (cond
     (instance? vec-math/Quaternion value) value
     (vector? value) (quat (get value 0 0) (get value 1 0) (get value 2 0) (get value 3 0))
     (number? value) (quat value value value value)
     :else (throw (Exception. (str "Invalid quaternion: " value)))))
  ([x y z w]
   (vec-math/Quaternion (double x) (double y) (double z) (double w))))

(defn ^vec-math/Vector3 vec3-zero
  "Creates a new `Vector3` object with all values set to zero."
  []
  (vec-math/Vector3.zero))

(defn ^vec-math/Matrix4 mat4-zero
  "Creates a new `Matrix4` object with all values set to zero."
  []
  (vec-math/Matrix4.zero))

(defn ^vec-math/Matrix4 mat4-identity
  "Creates a new `Matrix4` object with all values set to identity."
  []
  (vec-math/Matrix4.identity))

(defn ^vec-math/Matrix4 mat4-outer
  "Creates a new `Matrix4` object with the outer product of the given vectors."
  [u v]
  (vec-math/Matrix4.outer (vec3 u) (vec3 v)))

(defn ^vec-math/Matrix4 mat4-rotation-x
  "Creates a new `Matrix4` object with the given x rotation."
  [radians]
  (vec-math/Matrix4.rotationX (double radians)))

(defn ^vec-math/Matrix4 mat4-rotation-y
  "Creates a new `Matrix4` object with the given y rotation."
  [radians]
  (vec-math/Matrix4.rotationY (double radians)))

(defn ^vec-math/Matrix4 mat4-rotation-z
  "Creates a new `Matrix4` object with the given z rotation."
  [radians]
  (vec-math/Matrix4.rotationZ (double radians)))

(defn ^vec-math/Matrix4 mat4-skew
  "Creates a new `Matrix4` object with the given skew values."
  [alpha beta]
  (vec-math/Matrix4.skew (double alpha) (double beta)))

(defn ^vec-math/Matrix4 mat4-skew-x
  "Creates a new `Matrix4` object with the given x skew value."
  [alpha]
  (vec-math/Matrix4.skewX (double alpha)))

(defn ^vec-math/Matrix4 mat4-skew-y
  "Creates a new `Matrix4` object with the given y skew value."
  [beta]
  (vec-math/Matrix4.skewY (double beta)))

(defn ^vec-math/Matrix4 mat4-translation
  "Creates a new `Matrix4` object with the given translation values."
  ([vector]
   (vec-math/Matrix4.translation (vec3 vector)))
  ([x y z]
   (vec-math/Matrix4.translation (vec3 x y z)))
  ([x y]
   (mat4-translation x y 0)))

(defn ^vec-math/Matrix4 mat4-diagonal3
  ([x y z]
   (vec-math/Matrix4.diagonal3Values (double x) (double y) (double z)))
  ([scale]
   (vec-math/Matrix4.diagonal3 (vec3 scale))))

(defn ^vec-math/Quaternion quat-axis-angle
  "Creates a new `Quaternion` object with the given axis and angle."
  [axis angle]
  (vec-math/Quaternion.axisAngle (vec3 axis) (double angle)))

(defn ^vec-math/Quaternion quat-dq
  "Creates a new `Quaternion` object with the given q and omega values."
  [q omega]
  (vec-math/Quaternion.dq (quat q) (vec3 omega)))

(defn ^vec-math/Quaternion quat-euler
  "Creates a new `Quaternion` object with the given euler angles."
  [x y z]
  (vec-math/Quaternion.euler (double x) (double y) (double z)))

(defn ^vec-math/Quaternion quat-from-rotation
  "Creates a new `Quaternion` object with the given rotation matrix."
  [matrix]
  (vec-math/Quaternion.fromRotation (mat3 matrix)))

(defn ^vec-math/Quaternion quat-identity
  "Creates a new `Quaternion` object with all values set to identity."
  []
  (vec-math/Quaternion.identity))

(defn ^vec-math/Quaternion quat-random
  "Creates a new `Quaternion` object with random values."
  []
  (vec-math/Quaternion.random (math/Random.secure)))

(defn ^fd/ValueNotifier value
  "Creates a `ValueNotifier` that holds a single value and notifies listeners when changed.
     
   Also `ValueNotifier`:
     - Implements `IDeref` for @ syntax access to current value
     - Implements`IReset` for updating with reset!
     - Implements `ISwap` for functional updates with swap!
     
   `ValueNotifier` will notify its listeners whenever the value changes to something not equal to the previous value.
  
   ```clojure
   (widget
     :managed [counter (value 0)]
     (w/column
       (w/listening counter w/text)
       (->> (w/text \"Tap to increase!\")
            (w/button #(swap! counter inc))))
   ```"
  [initial-value]
  (fd/ValueNotifier initial-value))

(extend-protocol c/IDeref
  fd/ValueNotifier
  (-deref [this] (.-value this)))

(extend-protocol c/IReset
  fd/ValueNotifier
  (-reset! [this new-value] (.-value! this new-value)))

(extend-protocol c/ISwap
  fd/ValueNotifier
  (-swap! [this f] (.-value! this (f (.-value this))))
  (-swap! [this f a] (.-value! this (f (.-value this) a)))
  (-swap! [this f a b] (.-value! this (f (.-value this) a b)))
  (-swap! [this f a b xs] (.-value! this (apply f (.-value this) a b xs))))
