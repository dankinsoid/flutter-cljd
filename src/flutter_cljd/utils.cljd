(ns flutter-cljd.utils
  "Core utilities and helpers for flutter-cljd."
  (:require
   [cljd.flutter :as f]
   [cljd.set :as set]
   ["dart:math" :as math]
   ["dart:ui" :as ui]
   ["package:flutter/foundation.dart" :as fd]
   ["package:flutter/widgets.dart" :as w]))

(defmacro ??
  "A nil-coalescing macro that returns the first non-nil value from a series of expressions.
    
    Similar to `or`, but with a key difference: `??` only treats `nil` as a 'falsy' value, 
    whereas `or` treats both `nil` and `false` as 'falsy'. This makes `??` useful in cases where 
    `false` should be preserved as a valid return value.
  
    ### Usage
    - `(?? expr1 expr2 expr3 ...)` evaluates each expression in sequence until a non-nil value is found.
    - If `expr1` is non-nil, it is returned immediately, without evaluating `expr2` or `expr3`.
    - If all expressions are `nil`, the macro returns `nil`.
  
    ### Examples
  
    ```clojure
    ;; Returns the first non-nil value, which is 42
    (?? nil nil 42) ; => 42
  
    ;; If no non-nil values are found, returns nil
    (?? nil nil nil) ; => nil
  
    ;; Works with expressions and functions that return nil or non-nil values
    (?? (get {:a 1} :b) (get {:a 1} :a) (println \"Fallback\")) ; => 1
  
    ;; Unlike `or`, preserves `false` as a valid result
    (?? nil false 42) ; => false
    (or nil false 42) ; => 42
  
    ;; Stops evaluating as soon as a non-nil value is found
    (?? nil (do (println \"This is evaluated\") 2) 3) ; Prints 'This is evaluated' and returns 2
    ```"
  {:clj-kondo/lint-as 'clojure.core/or}
  ([] `nil)
  ([x] x)
  ([x & next]
   (reduce (fn [acc val]
             `(let [value# ~val]
                (if (some? value#)
                  value#
                  ~acc)))
           `nil
           (reverse (cons x next)))))

(def ^double π
  "The mathematical constant `π` (pi), which is the ratio of a circle's circumference to its diameter."
  math/pi)

(extend-protocol f/ITweenable
  w/Offset
  (-tween [end]
    (f/tween-with
     (fn [begin end]
       (fn [t] (w/Offset.lerp begin end t)))
     end))

  w/Shadow
  (-tween [end]
    (f/tween-with
     (fn [begin end]
       (fn [t] (w/Shadow.lerp begin end t)))
     end))

  w/BoxShadow
  (-tween [end]
    (f/tween-with
     (fn [begin end]
       (fn [t] (w/BoxShadow.lerp begin end t)))
     end)))

(defn int-lerp
  "Linear interpolation between two integers.
   
   Takes two integers and returns a function that interpolates between them based on a parameter t between 0 and 1.
   
   Args:
    - from: The starting integer
    - to: The ending integer 
    - t: The interpolation parameter between 0 and 1
   
   Returns:
    The interpolated integer
   
   Example:
   ```clojure
   (int-lerp 0 10 0.5) ; => 5
   ```"
  ([from to t]
   (.round (+ (* (- 1 t) from) (* t to))))
  ([from to]
   (fn [t] (int-lerp from to t))))

(defn lerp
  "Linear interpolation between two values.
   
   Takes two values and returns a function that interpolates between them based on a parameter t between 0 and 1.
   Can interpolate between numbers, vectors, sequences, and maps.
   
   Args:
    - from: The starting value
    - to: The ending value 
    - t: (optional) The interpolation parameter between 0 and 1
   
   Returns:
    If t is provided: The interpolated value
    If t is not provided: A function that takes t and returns the interpolated value
   
   Examples:
   ```clojure
   ;; Numbers
   ((lerp 0 10) 0.5) ; => 5
   (lerp 0 10 0.5)   ; => 5
   
   ;; Vectors
   ((lerp [0 0] [10 10]) 0.5)  ; => [5 5]
   
   ;; Maps
   ((lerp {:x 0} {:x 10}) 0.5) ; => {:x 5}
   ```"
  ([from to t]
   ((lerp from to) t))
  ([from to]
   (cond
     (and (number? from) (number? to))
     #(+ (* (- 1 %) (double from)) (* % (double to)))

     (satisfies? f/ITweenable from)
     (f/lerp from to)

     (and (vector? from) (vector? to) (= (count from) (count to)))
     (fn [t] (mapv #((lerp %1 %2) t) from to))

     (and (map? from) (map? to))
     (let [keys-from (set (keys from))
           keys-to (set (keys to))
           all-keys (set/union keys-from keys-to)]
       (when-not (= keys-from keys-to)
         (fd/FlutterError.reportError
          (fd/FlutterErrorDetails
           .exception (str "Warning: Maps '" from "' -> '" to "' have different keys " 
                           (set/difference all-keys (set/intersection keys-from keys-to))
                           " and may not animate correctly. "
                           "Make sure both maps have the same keys. " 
                           "Convert your values to a consistent type before animating if needed, for example: (t/insets :top 10) instead of {:top 10}.")
           .library "flutter-cljd"
           .context (fd/ErrorDescription "during animation setup"))))
       (fn [t]
         (reduce (fn [acc k]
                   (cond
                        ;; Key exists in both maps - interpolate
                     (and (contains? from k) (contains? to k))
                     (assoc acc k ((lerp (get from k) (get to k)) t))

                        ;; Key only in 'from' - keep if t < 0.5
                     (contains? from k)
                     (if (< t 0.5)
                       (assoc acc k (get from k))
                       acc)

                        ;; Key only in 'to' - keep if t >= 0.5
                     :else
                     (if (>= t 0.5)
                       (assoc acc k (get to k))
                       acc)))
                 {}
                 all-keys)))
     
     (= from to)
     (constantly to)

     :else
     #(if (> % 0.5) to from))))

;;; OKLab color space

(defn- srgb->linear ^double [^double c]
  (if (> c 0.04045)
    (math/pow (/ (+ c 0.055) 1.055) 2.4)
    (/ c 12.92)))

(defn- linear->srgb ^double [^double c]
  (if (> c 0.0031308)
    (- (* 1.055 (math/pow c (/ 1.0 2.4))) 0.055)
    (* 12.92 c)))

(defn- cbrt ^double [^double x]
  (if (>= x 0)
    (math/pow x (/ 1.0 3.0))
    (- (math/pow (- x) (/ 1.0 3.0)))))

(defn- clamp01 ^double [^double x]
  (max 0.0 (min 1.0 x)))

(defn color->oklab
  "Converts a `Color` to OKLab. Returns `[L a b alpha]`.

   ```clojure
   (color->oklab Colors.red) ; => [0.6279… 0.2248… 0.1258… 1.0]
   ```"
  [^ui/Color color]
  (let [r (srgb->linear (/ (.-red color) 255.0))
        g (srgb->linear (/ (.-green color) 255.0))
        b (srgb->linear (/ (.-blue color) 255.0))
        l (cbrt (+ (* 0.4122214708 r) (* 0.5363325363 g) (* 0.0514459929 b)))
        m (cbrt (+ (* 0.2119034982 r) (* 0.6806995451 g) (* 0.1073969566 b)))
        s (cbrt (+ (* 0.0883024619 r) (* 0.2817188376 g) (* 0.6299787005 b)))]
    [(+ (* 0.2104542553 l) (* 0.7936177850 m) (* -0.0040720468 s))
     (+ (* 1.9779984951 l) (* -2.4285922050 m) (* 0.4505937099 s))
     (+ (* 0.0259040371 l) (* 0.7827717662 m) (* -0.8086757660 s))
     (.-opacity color)]))

(defn oklab->color
  "Converts OKLab values to a `Color`.

   ```clojure
   (oklab->color [0.5 0.0 0.0 1.0])
   (oklab->color 0.5 0.0 0.0)
   (oklab->color 0.5 0.0 0.0 1.0)
   ```"
  ([[L a b alpha]]
   (oklab->color L a b alpha))
  ([L a b]
   (oklab->color L a b 1.0))
  ([L a b alpha]
   (let [l_ (+ L (* 0.3963377774 a) (* 0.2158037573 b))
         m_ (+ L (* -0.1055613458 a) (* -0.0638541728 b))
         s_ (+ L (* -0.0894841775 a) (* -1.2914855480 b))
         l (* l_ l_ l_)
         m (* m_ m_ m_)
         s (* s_ s_ s_)
         r (clamp01 (linear->srgb (+ (* 4.0767416621 l) (* -3.3077115913 m) (* 0.2309699292 s))))
         g (clamp01 (linear->srgb (+ (* -1.2684380046 l) (* 2.6097574011 m) (* -0.3413193965 s))))
         bl (clamp01 (linear->srgb (+ (* -0.0041960863 l) (* -0.7034186147 m) (* 1.7076147010 s))))]
     (ui/Color.fromRGBO
      (.round (* r 255))
      (.round (* g 255))
      (.round (* bl 255))
      (double alpha)))))

(defn oklab-lerp
  "Interpolates between two colors in OKLab color space.
   Produces perceptually uniform transitions unlike `Color.lerp` (which uses sRGB).

   ```clojure
   (oklab-lerp Colors.red Colors.blue 0.5)
   ((oklab-lerp Colors.red Colors.blue) 0.5) ; curried form for animations
   ```"
  ([from to t]
   ((oklab-lerp from to) (double t)))
  ([from to]
   (let [[l1 a1 b1 alpha1] (color->oklab from)
         [l2 a2 b2 alpha2] (color->oklab to)]
     (fn [^double t]
       (oklab->color
        (+ l1 (* t (- l2 l1)))
        (+ a1 (* t (- a2 a1)))
        (+ b1 (* t (- b2 b1)))
        (+ alpha1 (* t (- alpha2 alpha1))))))))

(defmulti expand-gradient-colors
  "Expands gradient colors in the given color space.
   Returns `[colors stops]`. Override for custom color spaces.

   Dispatches on `color-space` keyword (`:oklab`, `:srgb`, etc.)."
  (fn [color-space colors stops steps] color-space))

(defmethod expand-gradient-colors :srgb [_ colors stops _steps]
  [colors stops])

(defmethod expand-gradient-colors :oklab [_ colors stops steps]
  (let [n (count colors)
        stops (or stops (mapv #(/ (double %) (dec n)) (range n)))
        result (mapcat
                (fn [i]
                  (let [f (oklab-lerp (nth colors i) (nth colors (inc i)))
                        s1 (nth stops i)
                        s2 (nth stops (inc i))
                        end (if (= i (- n 2)) (inc steps) steps)]
                    (map (fn [j]
                           (let [t (/ (double j) steps)]
                             [(f t) (+ s1 (* t (- s2 s1)))]))
                         (range end))))
                (range (dec n)))]
    [(mapv first result) (mapv second result)]))

(extend-protocol f/ITweenable
  ui/Color
  (-tween [end]
    (f/tween-with
     (fn [begin end]
       (oklab-lerp begin end))
     end)))

;;; OKLCH color space (OKLab in polar coordinates)

(defn color->oklch
  "Converts a `Color` to OKLCH. Returns `[L C H alpha]`.
   L: lightness [0,1], C: chroma [0,~0.4], H: hue [−π, π].

   ```clojure
   (color->oklch Colors.red) ; => [0.6279… 0.2576… 0.5016… 1.0]
   ```"
  [^ui/Color color]
  (let [[L a b alpha] (color->oklab color)]
    [L (math/sqrt (+ (* a a) (* b b))) (math/atan2 b a) alpha]))

(defn oklch->color
  "Converts OKLCH values to a `Color`.

   ```clojure
   (oklch->color [0.5 0.1 0.0 1.0])
   (oklch->color 0.5 0.1 0.0)
   (oklch->color 0.5 0.1 0.0 1.0)
   ```"
  ([[L C H alpha]]
   (oklch->color L C H alpha))
  ([L C H]
   (oklch->color L C H 1.0))
  ([L C H alpha]
   (let [C (double C)
         H (double H)]
     (oklab->color L (* C (math/cos H)) (* C (math/sin H)) alpha))))

(defn- lerp-hue ^double [^double h1 ^double h2 ^double t]
  (let [diff (- h2 h1)
        diff (cond
               (> diff math/pi) (- diff (* 2 math/pi))
               (< diff (- math/pi)) (+ diff (* 2 math/pi))
               :else diff)]
    (+ h1 (* t diff))))

(defn oklch-lerp
  "Interpolates between two colors in OKLCH color space.
   Hue is interpolated along the shortest arc.

   ```clojure
   (oklch-lerp Colors.red Colors.blue 0.5)
   ((oklch-lerp Colors.red Colors.blue) 0.5) ; curried form for animations
   ```"
  ([from to t]
   ((oklch-lerp from to) (double t)))
  ([from to]
   (let [[l1 c1 h1 alpha1] (color->oklch from)
         [l2 c2 h2 alpha2] (color->oklch to)]
     (fn [^double t]
       (oklch->color
        (+ l1 (* t (- l2 l1)))
        (+ c1 (* t (- c2 c1)))
        (lerp-hue h1 h2 t)
        (+ alpha1 (* t (- alpha2 alpha1))))))))

(defmethod expand-gradient-colors :oklch [_ colors stops steps]
  (let [n (count colors)
        stops (or stops (mapv #(/ (double %) (dec n)) (range n)))
        result (mapcat
                (fn [i]
                  (let [f (oklch-lerp (nth colors i) (nth colors (inc i)))
                        s1 (nth stops i)
                        s2 (nth stops (inc i))
                        end (if (= i (- n 2)) (inc steps) steps)]
                    (map (fn [j]
                           (let [t (/ (double j) steps)]
                             [(f t) (+ s1 (* t (- s2 s1)))]))
                         (range end))))
                (range (dec n)))]
    [(mapv first result) (mapv second result)]))

(defn flatten-children
  "Flattens a nested collection of children and filters out non-Widget elements.
   
   Used internally by widget functions to handle nested collections of children.
   
   Args:
    - children: A collection that may contain widgets and nested collections
   
   Returns:
    A flat sequence containing only Widget instances
   
   Example:
   ```clojure
   (flatten-children [[button1 button2] text1 [text2]])
   ; => [button1 button2 text1 text2]
   ```"
  [children]
  (filter #(instance? w/Widget %) (flatten children)))

(defn args-children
  "Processes arguments and children for widget functions that accept both options and children.
   
   Used internally by widget functions to handle flexible argument patterns where the first argument
   can either be a map of options or a child widget.
   
   Args:
    - args: Either a map of options or the first child widget
    - children: Sequence of child widgets (may be empty if args is a child)
   
   Returns:
    A vector containing:
    - A map of processed arguments (empty if args was a child)
    - A flattened sequence of Widget children
   
   Example:
   ```clojure
   ;; With options map
   (args-children {:color :red} [child1 child2])
   ; => [{:color :red} [child1 child2]]
   
   ;; Without options map
   (args-children first-child [child2 child3])
   ; => [{} [first-child child2 child3]]
   ```"
  ([args children]
   [(if (map? args) args {})
    (flatten-children (if (map? args) children (cons args children)))]))

(defn key-values-args-and-children [values]
  (if (map? (first values))
    (args-children (first values) (rest values))
    (let [{:keys [args i]} (reduce
                                (fn [{:keys [args key i]} v]
                                  (cond
                                    (and (even? i) (keyword? v))
                                    {:args args :key v :i (inc i)}
                                    (and (odd? i) (some? key))
                                    {:args (assoc args key v) :i (inc i)}
                                    :else
                                    (reduced {:args args :i i})))
                                {:args {} :i 0}
                                values)]
      (args-children args (vec (drop i values))))))

(defn key-values-map [values]
  (if (= 1 (count values)) (first values) (into {} (map vec (partition 2 values)))))

(defmacro dbg
  "Prints variable names and their values.
    
    ```clojure
    (let [x 10 y 20]
      (dbg x y))
    ;; Output: x: 10 y: 20
   ```"
  [& vars]
  `(println ~@(map (fn [v] `(str '~v ": " (if (nil? ~v) "nil" ~v))) vars)))
